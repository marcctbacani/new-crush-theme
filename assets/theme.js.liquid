var ProductView,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  slice = [].slice;

window.HeaderView = (function(superClass) {
  extend(HeaderView, superClass);

  function HeaderView() {
    return HeaderView.__super__.constructor.apply(this, arguments);
  }

  HeaderView.prototype.events = {
    "click .mobile-header-search-toggle": "toggleSearch",
    "blur .header-search-input": "toggleSearch"
  };

  HeaderView.prototype.initialize = function(options) {
    this.sectionBinding();
    return this.validate();
  };

  HeaderView.prototype.validate = function() {
    window.Pacific = {};
    Pacific.settings = {{ settings | json }};
    if (Pacific.settings["enable_currency_switcher"]) {
      return new CurrencyView({
        el: this.$(".currency-switcher")
      });
    }
  };

  HeaderView.prototype.sectionBinding = function() {
    this.$el.on('shopify:section:load', (function(_this) {
      return function(event) {
        if (!$(event.target).hasClass('section-header')) {
          return;
        }
        _this.delegateEvents();
        return _this.validate();
      };
    })(this));
    return this.$el.on('shopify:section:unload', (function(_this) {
      return function(event) {
        if (!$(event.target).hasClass('section-header')) {
          return;
        }
        return _this.undelegateEvents();
      };
    })(this));
  };

  HeaderView.prototype.toggleSearch = function() {
    var form;
    if (!(document.documentElement.clientWidth > 1020)) {
      form = this.$(".header-search-form");
      if (form.hasClass("active")) {
        return form.removeClass("active");
      } else {
        return form.addClass("active").find("input").focus();
      }
    }
  };

  return HeaderView;

})(Backbone.View);

window.CurrencyView = (function(superClass) {
  extend(CurrencyView, superClass);

  function CurrencyView() {
    return CurrencyView.__super__.constructor.apply(this, arguments);
  }

  CurrencyView.prototype.events = {
    "change [name=currencies]": "switchCurrency",
    "switch-currency": "switchCurrency"
  };

  CurrencyView.prototype.initialize = function() {
    var newCurrency;
    Currency.format = Shop.currencySwitcherFormat;
    Currency.money_with_currency_format = {};
    Currency.money_with_currency_format[Shop.currency] = Shop.moneyFormatCurrency;
    Currency.money_format = {};
    Currency.money_format[Shop.currency] = Shop.moneyFormat;
    newCurrency = Currency.cookie.read();
    if (newCurrency && this.$("[name=currencies] option[value=" + newCurrency + "]")) {
      Currency.currentCurrency = newCurrency;
    } else if (Shop.defaultCurrency) {
      Currency.currentCurrency = Shop.defaultCurrency;
      Currency.cookie.write(Shop.defaultCurrency);
    } else {
      Currency.currentCurrency = Shop.currency;
      Currency.cookie.write(Shop.currency);
    }
    $("[name=currencies]").val(Currency.currentCurrency);
    return $(window).load((function(_this) {
      return function() {
        var doubleMoney, j, l, len, len1, money, ref1, ref2;
        ref1 = $("span.money span.money");
        for (j = 0, len = ref1.length; j < len; j++) {
          doubleMoney = ref1[j];
          $(doubleMoney).parents("span.money").removeClass("money");
        }
        ref2 = $("span.money");
        for (l = 0, len1 = ref2.length; l < len1; l++) {
          money = ref2[l];
          $(money).attr("data-currency-" + Shop.currency, $(money).html());
        }
        return _this.switchCurrency();
      };
    })(this));
  };

  CurrencyView.prototype.switchCurrency = function(e) {
    var $switcher, j, len, money, newCurrency, ref1;
    $switcher = $("[name=currencies]");
    newCurrency = $switcher.val();
    if (e !== void 0) {
      $switcher = $(e.currentTarget);
      if ($switcher !== void 0 && ($switcher != null ? $switcher.attr('name') : void 0) === 'currencies') {
        newCurrency = $switcher.val();
      }
    }
    if (newCurrency === null || newCurrency === '') {
      newCurrency = Shop.currency;
    }
    ref1 = $("span.money");
    for (j = 0, len = ref1.length; j < len; j++) {
      money = ref1[j];
      $(money).html($(money).attr("data-currency-" + Shop.currency));
      $(money).attr("data-currency", Shop.currency);
    }
    Currency.convertAll(Shop.currency, newCurrency);
    Currency.currentCurrency = newCurrency;
    Currency.cookie.write(newCurrency);
    return this.$(".selected-currency").text(Currency.currentCurrency);
  };

  return CurrencyView;

})(Backbone.View);

window.NavigationView = (function(superClass) {
  extend(NavigationView, superClass);

  function NavigationView() {
    return NavigationView.__super__.constructor.apply(this, arguments);
  }

  NavigationView.prototype.events = {
    "click .mobile-navigation-toggle": "toggleMobileNavigation",
    "click .mobile-tier-toggle": "toggleMobileTier",
    "click .has-children > a": "changeTier",
    "click .mega-nav-breadcrumbs span": "previousTier",
    "click .bacon-menu-button": "baconMenu",
    'mouseenter [aria-haspopup]': 'setExpanded',
    'mouseleave [aria-haspopup]': 'unsetExpanded'
  };

  NavigationView.prototype.initialize = function() {
    this.initializedClass = 'navigation-initialized';
    return this._validate();
  };

  NavigationView.prototype.update = function($el) {
    this.$el = $el;
    return this._validate();
  };

  NavigationView.prototype.setExpanded = function(e) {
    var $link;
    $link = $(e.currentTarget);
    return $link.attr("aria-expanded", true);
  };

  NavigationView.prototype.unsetExpanded = function(e) {
    var $link;
    $link = $(e.currentTarget);
    return $link.attr("aria-expanded", false);
  };

  NavigationView.prototype._validate = function() {
    var isInitialized;
    this.body = $(document.body);
    this.navigation = $('.navigation', this.$el);
    this.windowWidth = this.windowWidth = document.documentElement.clientWidth;
    isInitialized = this.$el.hasClass(this.initializedClass);
    this.transitionend = (function(transition) {
      var transEndEventNames;
      transEndEventNames = {
        "-webkit-transition": "webkitTransitionEnd",
        "-moz-transition": "transitionend",
        "-o-transition": "oTransitionEnd",
        transition: "transitionend"
      };
      return transEndEventNames[transition];
    })(Modernizr.prefixed("transition"));
    this.checkDropdownWidth();
    if (this.$("li.mega-nav").length) {
      this.prepareMegaNav();
    }
    return $(window).on("resize", (function(_this) {
      return function() {
        _this.setWindowWidth();
        if (_this.$("li.mega-nav").length) {
          _this.prepareMegaNav();
        }
        if (_this.navigation.hasClass("mobile-visible") && _this.windowWidth > 1020) {
          _this.navigation.removeClass("mobile-visible");
          return _this.resetHeights();
        }
      };
    })(this));
  };

  NavigationView.prototype.setWindowWidth = function() {
    return this.windowWidth = document.documentElement.clientWidth;
  };

  NavigationView.prototype.baconMenu = function(event) {
    var $linkItem, $menuWrapper;
    $linkItem = $(event.currentTarget);
    $menuWrapper = $linkItem.parents(".tier-1");
    $menuWrapper.find("li").css("height", "");
    return $(".bacon-menu-button.active").each(function() {
      var $current;
      $current = $(this);
      if ($current.next("div").is(":hidden")) {
        return $current.removeClass("active");
      }
    });
  };

  NavigationView.prototype.checkDropdownWidth = function() {
    var item, itemOffset, j, len, ref1, results;
    ref1 = this.$(".tier-1 > .has-dropdown");
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      item = ref1[j];
      item = $(item);
      if (!item.hasClass("mega-nav")) {
        itemOffset = item.offset();
        if (item.find(".tier-2").length && itemOffset.left + 200 > this.windowWidth) {
          item.addClass("alternate-drop");
        }
        if (item.find(".tier-3").length && itemOffset.left + 400 > this.windowWidth) {
          results.push(item.addClass("alternate-drop"));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  NavigationView.prototype.toggleMobileNavigation = function() {
    var firstTier, height;
    if (!this.navigation.hasClass("processed")) {
      $(window).on("resize", (function(_this) {
        return function() {
          return _.debounce(function() {
            if (_this.windowWidth > 1020) {
              return _this.resetHeights();
            }
          }, 500);
        };
      })(this));
      this.navigation.addClass("processed");
    }
    firstTier = this.$(".tier-1");
    if (this.navigation.hasClass("mobile-visible")) {
      if (this.body.hasClass("bacon-menu-loaded")) {
        this.navigation.find(".bacon-menu-button.active").each(function() {
          return $(this).trigger("click");
        });
        this.navigation.find(".bacon-highway-mobile.active").each(function() {
          return $(this).trigger("click");
        });
      }
      this.navigation.removeClass("mobile-visible");
      return this.resetHeights();
    } else {
      height = this.getHiddenHeight(firstTier);
      firstTier.addClass("open");
      return setTimeout(((function(_this) {
        return function() {
          _this.navigation.addClass("mobile-visible");
          $(".mobile-navigation-toggle").addClass("active");
          return firstTier.css("height", height);
        };
      })(this)), 50);
    }
  };

  NavigationView.prototype.toggleMobileTier = function(e) {
    var height, list, parent;
    e.preventDefault();
    e.stopPropagation();
    parent = $(e.target).closest(".has-dropdown, .mega-nav, .mega-nav-item, .has-children");
    list = parent.find("> ul");
    if (parent.hasClass("open")) {
      height = list.height();
      list.parents("ul").css("height", "-=" + height);
      list.find(".open").removeClass("open").find("> ul").css("height", "");
      if (Modernizr.csstransitions) {
        return list.height(0).one(this.transitionend, (function(_this) {
          return function() {
            return parent.removeClass("open");
          };
        })(this));
      } else {
        return parent.removeClass("open");
      }
    } else {
      height = this.getHiddenHeight(list);
      parent.addClass("open");
      list.css("height", height);
      return list.parents("ul").css("height", "+=" + height);
    }
  };

  NavigationView.prototype.getHiddenHeight = function(elem) {
    var height, temp;
    temp = $(elem).clone().addClass("cloned-list").appendTo(this.navigation);
    height = temp.height();
    temp.remove();
    return height;
  };

  NavigationView.prototype.resetHeights = function() {
    var $list, j, len, list, ref1;
    ref1 = this.$("ul");
    for (j = 0, len = ref1.length; j < len; j++) {
      list = ref1[j];
      $list = $(list);
      $list.parent("li").css("min-height", "");
      $list.css("min-height", "").css("height", "").parent().removeClass("open");
    }
    return $(".mobile-navigation-toggle").removeClass("active");
  };

  NavigationView.prototype.prepareMegaNav = function() {
    var navigationWidth;
    this.$el.toggleClass(this.initializedClass, true);
    this.megaNavDropdown = this.$(".mega-nav-dropdown");
    if (this.windowWidth > 1020) {
      navigationWidth = this.navigation.width();
      return this.megaNavDropdown.css({
        width: navigationWidth,
        marginLeft: -(navigationWidth / 2)
      });
    } else {
      return this.megaNavDropdown.css({
        top: "",
        width: "",
        marginLeft: ""
      });
    }
  };

  NavigationView.prototype.setMegaNav = function(e) {
    var firstTierHeight;
    if (this.windowWidth < 1021) {
      return;
    }
    firstTierHeight = this.megaNavDropdown.height();
    return this.megaNavDropdown.data("first-tier-height", firstTierHeight).height(firstTierHeight);
  };

  NavigationView.prototype.resetMegaNav = function(e) {
    if (this.windowWidth < 1021) {
      return;
    }
    if (e && $(e.relatedTarget).closest(".mega-nav").length) {
      return;
    }
    this.megaNavDropdown.height(this.megaNavDropdown.data("first-tier-height"));
    return this.$(".active").removeClass("active");
  };

  NavigationView.prototype.changeTier = function(e) {
    var currentHeight, nextTier, nextTierHeight;
    if (this.windowWidth < 1021) {
      return;
    }
    e.preventDefault();
    $(e.currentTarget).addClass("working");
    nextTier = $(e.currentTarget).next("ul");
    nextTierHeight = nextTier.outerHeight();
    currentHeight = this.megaNavDropdown.height();
    if (currentHeight < nextTierHeight) {
      this.megaNavDropdown.height(nextTierHeight);
    } else {
      nextTier.css({
        "bottom": 0
      });
    }
    return $(e.currentTarget).removeClass("working").addClass("active");
  };

  NavigationView.prototype.previousTier = function(e) {
    var previousTierHeight;
    if ($(e.currentTarget).hasClass("current-tier")) {
      return;
    }
    if ($(e.currentTarget).hasClass("tier-1")) {
      this.$(".active").removeClass("active");
      this.megaNavDropdown.height(this.megaNavDropdown.data("first-tier-height"));
    } else {
      $(e.currentTarget).closest("ul").siblings(".active").removeClass("active");
      previousTierHeight = $(e.currentTarget).closest(".mega-nav-tier-2").outerHeight();
      this.megaNavDropdown.height(previousTierHeight);
    }
    if (!this.$(".active").length) {
      return this.resetMegaNav();
    }
  };

  return NavigationView;

})(Backbone.View);

window.SlideshowView = (function(superClass) {
  extend(SlideshowView, superClass);

  function SlideshowView() {
    return SlideshowView.__super__.constructor.apply(this, arguments);
  }

  SlideshowView.prototype.events = {
    "click .previous-slide": "previousSlide",
    "click .next-slide": "nextSlide",
    "click .slideshow-pagination > span": "specificSlide",
    "mouseenter": "pauseLoop",
    "mouseleave": "startLoop"
  };

  SlideshowView.prototype.initialize = function() {
    this.initializedClass = 'slideshow-initialized';
    return this._validate();
  };

  SlideshowView.prototype.update = function($el) {
    this.$el = $el;
    return this._validate();
  };

  SlideshowView.prototype._validate = function() {
    this.navigation = this.$(".slideshow-navigation", this.$el);
    this.pagination = this.$(".slideshow-pagination", this.$el);
    this.autoplay = parseInt($(".home-slideshow", this.$el).attr("data-slideshow-autoplay"), 10);
    this.setWindowWidth();
    this.setupSlides();
    return this.transitionend = (function(transition) {
      var transEndEventNames;
      transEndEventNames = {
        "-webkit-transition": "webkitTransitionEnd",
        "-moz-transition": "transitionend",
        "-o-transition": "oTransitionEnd",
        transition: "transitionend"
      };
      return transEndEventNames[transition];
    })(Modernizr.prefixed("transition"));
  };

  SlideshowView.prototype.lockSlide = function(event) {
    this.slidesLocked = true;
    this.pauseLoop();
    this.specificSlideBlock(event);
    return this.selectedHeight(event);
  };

  SlideshowView.prototype.unlockSlide = function() {
    this.slidesLocked = false;
    return this.startLoop();
  };

  SlideshowView.prototype.setWindowWidth = function() {
    return this.windowWidth = document.documentElement.clientWidth;
  };

  SlideshowView.prototype.setupSlides = function() {
    var paginationWidth;
    this.slides = this.$(".slideshow-slide", this.$el);
    this.slideCount = this.slides.length;
    this.pagination.find("span:first").addClass("active");
    if (!Modernizr.csstransforms) {
      paginationWidth = this.pagination.width();
      this.pagination.css({
        marginLeft: -(paginationWidth / 2)
      });
    }
    return this.$el.imagesLoaded((function(_this) {
      return function() {
        var i, image, imageHeight, j, len, ref1, slide, slideContent, slideHeight, slideID, textHeight;
        ref1 = _this.slides;
        for (i = j = 0, len = ref1.length; j < len; i = ++j) {
          slide = ref1[i];
          slide = $(slide);
          slideID = slide.attr("id");
          image = slide.find(".slide-image", _this.$el);
          imageHeight = image.height();
          slide.data("height", imageHeight);
          slideHeight = _this.windowWidth <= 540 ? slide.height() : imageHeight;
          if (!Modernizr.csstransforms) {
            slideContent = slide.find(".slide-content");
            textHeight = slideContent.height();
            slideContent.css({
              marginTop: -(textHeight / 2)
            });
          }
          if (i === 0) {
            slide.addClass("active");
            $(".home-slideshow", _this.$el).height(slideHeight);
            _this.navigation.css({
              paddingTop: ((imageHeight - 48) / 2) + "px"
            });
            _this.resetPaginationPosition(imageHeight);
          }
          if (i + 1 === _this.slideCount) {
            $(".home-slideshow", _this.$el).addClass("slides-ready");
          }
        }
        $(window).on("resize", function() {
          _this.setWindowWidth();
          return _this.resetSlideHeights();
        });
        if (_this.autoplay > 0) {
          _this.delay = parseInt(_this.autoplay, 10) * 1000;
          return _this.startLoop();
        }
      };
    })(this));
  };

  SlideshowView.prototype.resetSlideHeights = function() {
    var image, imageHeight, j, len, ref1, results, slide, slideHeight;
    ref1 = this.slides;
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      slide = ref1[j];
      slide = $(slide);
      image = slide.find(".slide-image");
      imageHeight = image.height();
      slide.css("height", "");
      slide.data("height", imageHeight);
      slideHeight = this.windowWidth <= 540 ? slide.height() : imageHeight;
      if (slide.hasClass("active")) {
        $(".home-slideshow", this.$el).height(slideHeight);
        this.navigation.css({
          paddingTop: ((imageHeight - 48) / 2) + "px"
        });
        results.push(this.resetPaginationPosition(imageHeight));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  SlideshowView.prototype.selectedHeight = function(event) {
    return $(event.target).imagesLoaded((function(_this) {
      return function() {
        return setTimeout((function() {
          var imageHeight;
          $('.slideshow-slide', _this.$el).removeClass('active');
          $(event.target).addClass('active');
          imageHeight = $(event.target).height();
          $('.home-slideshow', _this.$el).css({
            height: $(event.target).height()
          });
          return _this.navigation.css({
            paddingTop: ((imageHeight - 48) / 2) + "px"
          });
        }), 500);
      };
    })(this));
  };

  SlideshowView.prototype.resetPaginationPosition = function(height) {
    if (this.windowWidth <= 540) {
      return this.pagination.css({
        bottom: "auto",
        top: height - 50
      });
    } else {
      return this.pagination.css({
        bottom: 0,
        top: "auto"
      });
    }
  };

  SlideshowView.prototype.previousSlide = function(e) {
    if (this.sliding) {
      return;
    }
    this.showNewSlide("prev");
    return e.preventDefault();
  };

  SlideshowView.prototype.nextSlide = function(e) {
    if (this.sliding) {
      return;
    }
    this.showNewSlide("next");
    if (e) {
      return e.preventDefault();
    }
  };

  SlideshowView.prototype.specificSlideBlock = function(event) {
    var nextSlideID;
    nextSlideID = $(event.target).data("slide-id");
    return this.showNewSlide("next", nextSlideID);
  };

  SlideshowView.prototype.specificSlide = function(event) {
    var nextSlideID;
    if (!$(event.currentTarget).hasClass("active")) {
      nextSlideID = $(event.currentTarget).data("slide-id");
      console.log('pagination currentTarget', event.currentTarget);
      console.log('pagination next ID', nextSlideID);
      return this.showNewSlide("next", nextSlideID);
    }
  };

  SlideshowView.prototype.updateSlidePagination = function(index) {
    this.pagination.find(".active").removeClass("active");
    return this.pagination.find("> span").eq(index).addClass("active");
  };

  SlideshowView.prototype.showNewSlide = function(type, specificSlide) {
    var activeSlide, called, direction, fallback, imageHeight, nextSlide, slideHeight, slideID;
    this.sliding = true;
    called = false;
    if (this.slides.length === 1) {
      this.sliding = false;
      return;
    }
    direction = type === "next" ? "left" : "right";
    fallback = type === "next" ? "first" : "last";
    activeSlide = this.$(".slideshow-slide.active");
    nextSlide = specificSlide ? this.$("#" + specificSlide) : activeSlide[type]();
    nextSlide = nextSlide.length ? nextSlide : this.slides[fallback]();
    nextSlide.addClass(type);
    nextSlide[0].offsetWidth;
    activeSlide.addClass(direction);
    nextSlide.addClass(direction);
    if (Modernizr.csstransitions) {
      nextSlide.one(this.transitionend, (function(_this) {
        return function() {
          called = true;
          nextSlide.removeClass([type, direction].join(" ")).addClass("active");
          activeSlide.removeClass(["active", direction].join(" "));
          return _this.sliding = false;
        };
      })(this));
      setTimeout((function(_this) {
        return function() {
          if (!called) {
            return nextSlide.trigger(_this.transitionend);
          }
        };
      })(this), 300 + 10);
    } else {
      nextSlide.removeClass([type, direction].join(" ")).addClass("active");
      activeSlide.removeClass(["active", direction].join(" "));
      this.sliding = false;
    }
    imageHeight = nextSlide.data("height");
    this.updateSlidePagination(nextSlide.index());
    this.resetPaginationPosition(imageHeight);
    this.navigation.css({
      paddingTop: ((imageHeight - 48) / 2) + "px"
    });
    slideHeight = this.windowWidth <= 720 ? nextSlide.height() : imageHeight;
    slideID = nextSlide.attr('id');
    return $(".home-slideshow", this.$el).height(slideHeight);
  };

  SlideshowView.prototype.startLoop = function() {
    if (this.autoplay > 0) {
      if (!this.loop) {
        this.loop = true;
        return this.autoplayInt = setInterval((function(_this) {
          return function() {
            return _this.nextSlide();
          };
        })(this), this.delay);
      }
    }
  };

  SlideshowView.prototype.pauseLoop = function() {
    this.loop = false;
    return clearInterval(this.autoplayInt);
  };

  return SlideshowView;

})(Backbone.View);

window.SidebarView = (function(superClass) {
  extend(SidebarView, superClass);

  function SidebarView() {
    return SidebarView.__super__.constructor.apply(this, arguments);
  }

  SidebarView.prototype.events = {
    "click .has-children > a": "toggleDropdown"
  };

  SidebarView.prototype.initialize = function() {};

  SidebarView.prototype.toggleDropdown = function(e) {
    if (document.documentElement.clientWidth < 721) {
      e.preventDefault();
      $(e.target).parent().toggleClass("open");
      return false;
    }
  };

  return SidebarView;

})(Backbone.View);


/*********************************************************************
*  #### Twitter Post Fetcher v17.0.3 ####
*  Coded by Jason Mayes 2015. A present to all the developers out there.
*  www.jasonmayes.com
*  Please keep this disclaimer with my code if you use it. Thanks. :-)
*  Got feedback or questions, ask here:
*  http://www.jasonmayes.com/projects/twitterApi/
*  Github: https://github.com/jasonmayes/Twitter-Post-Fetcher
*  Updates will be posted to this site.
*********************************************************************/
(function(root,factory){if(typeof define==='function'&&define.amd){define([],factory);}else if(typeof exports==='object'){module.exports=factory();}else{factory();}}(this,function(){var domNode='';var maxTweets=20;var parseLinks=true;var queue=[];var inProgress=false;var printTime=true;var printUser=true;var formatterFunction=null;var supportsClassName=true;var showRts=true;var customCallbackFunction=null;var showInteractionLinks=true;var showImages=false;var useEmoji=false;var targetBlank=true;var lang='en';var permalinks=true;var dataOnly=false;var script=null;var scriptAdded=false;function handleTweets(tweets){if(customCallbackFunction===null){var x=tweets.length;var n=0;var element=document.getElementById(domNode);var html='<ul>';while(n<x){html+='<li>'+tweets[n]+'</li>';n++;}
html+='</ul>';element.innerHTML=html;}else{customCallbackFunction(tweets);}}
function strip(data){return data.replace(/<b[^>]*>(.*?)<\/b>/gi,function(a,s){return s;}).replace(/class="(?!(tco-hidden|tco-display|tco-ellipsis))+.*?"|data-query-source=".*?"|dir=".*?"|rel=".*?"/gi,'');}
function targetLinksToNewWindow(el){var links=el.getElementsByTagName('a');for(var i=links.length-1;i>=0;i--){links[i].setAttribute('target','_blank');}}
function getElementsByClassName(node,classname){var a=[];var regex=new RegExp('(^| )'+classname+'( |$)');var elems=node.getElementsByTagName('*');for(var i=0,j=elems.length;i<j;i++){if(regex.test(elems[i].className)){a.push(elems[i]);}}
return a;}
function extractImageUrl(image_data){if(image_data!==undefined&&image_data.innerHTML.indexOf('data-image')>=0){var data_src=image_data.innerHTML.match(/data-image=\"([A-z0-9]+:\/\/[A-z0-9]+\.[A-z0-9]+\.[A-z0-9]+\/[A-z0-9]+\/[A-z0-9\-]+)/i)[1];return decodeURIComponent(data_src)+'.jpg';}}
var twitterFetcher={fetch:function(config){if(config.maxTweets===undefined){config.maxTweets=20;}
if(config.enableLinks===undefined){config.enableLinks=true;}
if(config.showUser===undefined){config.showUser=true;}
if(config.showTime===undefined){config.showTime=true;}
if(config.dateFunction===undefined){config.dateFunction='default';}
if(config.showRetweet===undefined){config.showRetweet=true;}
if(config.customCallback===undefined){config.customCallback=null;}
if(config.showInteraction===undefined){config.showInteraction=true;}
if(config.showImages===undefined){config.showImages=false;}
if(config.useEmoji===undefined){config.useEmoji=false;}
if(config.linksInNewWindow===undefined){config.linksInNewWindow=true;}
if(config.showPermalinks===undefined){config.showPermalinks=true;}
if(config.dataOnly===undefined){config.dataOnly=false;}
if(inProgress){queue.push(config);}else{inProgress=true;domNode=config.domId;maxTweets=config.maxTweets;parseLinks=config.enableLinks;printUser=config.showUser;printTime=config.showTime;showRts=config.showRetweet;formatterFunction=config.dateFunction;customCallbackFunction=config.customCallback;showInteractionLinks=config.showInteraction;showImages=config.showImages;useEmoji=config.useEmoji;targetBlank=config.linksInNewWindow;permalinks=config.showPermalinks;dataOnly=config.dataOnly;var head=document.getElementsByTagName('head')[0];if(script!==null){head.removeChild(script);}
script=document.createElement('script');script.type='text/javascript';if(config.list!==undefined){script.src='https://syndication.twitter.com/timeline/list?'+'callback=__twttrf.callback&dnt=false&list_slug='+
config.list.listSlug+'&screen_name='+config.list.screenName+'&suppress_response_codes=true&lang='+(config.lang||lang)+'&rnd='+Math.random();}else if(config.profile!==undefined){script.src='https://syndication.twitter.com/timeline/profile?'+'callback=__twttrf.callback&dnt=false'+'&screen_name='+config.profile.screenName+'&suppress_response_codes=true&lang='+(config.lang||lang)+'&rnd='+Math.random();}else if(config.likes!==undefined){script.src='https://syndication.twitter.com/timeline/likes?'+'callback=__twttrf.callback&dnt=false'+'&screen_name='+config.likes.screenName+'&suppress_response_codes=true&lang='+(config.lang||lang)+'&rnd='+Math.random();}else{script.src='https://cdn.syndication.twimg.com/widgets/timelines/'+
config.id+'?&lang='+(config.lang||lang)+'&callback=__twttrf.callback&'+'suppress_response_codes=true&rnd='+Math.random();}
head.appendChild(script);}},callback:function(data){if(data===undefined||data.body===undefined){inProgress=false;if(queue.length>0){twitterFetcher.fetch(queue[0]);queue.splice(0,1);}
return;}
if(!useEmoji){data.body=data.body.replace(/(<img[^c]*class="Emoji[^>]*>)|(<img[^c]*class="u-block[^>]*>)/g,'');}
if(!showImages){data.body=data.body.replace(/(<img[^c]*class="NaturalImage-image[^>]*>|(<img[^c]*class="CroppedImage-image[^>]*>))/g,'');}
if(!printUser){data.body=data.body.replace(/(<img[^c]*class="Avatar"[^>]*>)/g,'');}
var div=document.createElement('div');div.innerHTML=data.body;if(typeof(div.getElementsByClassName)==='undefined'){supportsClassName=false;}
function swapDataSrc(element){var avatarImg=element.getElementsByTagName('img')[0];if(avatarImg && avatarImg.length){avatarImg.src=avatarImg.getAttribute('data-src-2x');}return element;}
var tweets=[];var authors=[];var times=[];var images=[];var rts=[];var tids=[];var permalinksURL=[];var x=0;if(supportsClassName){var tmp=div.getElementsByClassName('timeline-Tweet');while(x<tmp.length){if(tmp[x].getElementsByClassName('timeline-Tweet-retweetCredit').length>0){rts.push(true);}else{rts.push(false);}
if(!rts[x]||rts[x]&&showRts){tweets.push(tmp[x].getElementsByClassName('timeline-Tweet-text')[0]);tids.push(tmp[x].getAttribute('data-tweet-id'));if(printUser){authors.push(swapDataSrc(tmp[x].getElementsByClassName('timeline-Tweet-author')[0]));}
times.push(tmp[x].getElementsByClassName('dt-updated')[0]);permalinksURL.push(tmp[x].getElementsByClassName('timeline-Tweet-timestamp')[0]);if(tmp[x].getElementsByClassName('timeline-Tweet-media')[0]!==undefined){images.push(tmp[x].getElementsByClassName('timeline-Tweet-media')[0]);}else{images.push(undefined);}}
x++;}}else{var tmp=getElementsByClassName(div,'timeline-Tweet');while(x<tmp.length){if(getElementsByClassName(tmp[x],'timeline-Tweet-retweetCredit').length>0){rts.push(true);}else{rts.push(false);}
if(!rts[x]||rts[x]&&showRts){tweets.push(getElementsByClassName(tmp[x],'timeline-Tweet-text')[0]);tids.push(tmp[x].getAttribute('data-tweet-id'));if(printUser){authors.push(swapDataSrc(getElementsByClassName(tmp[x],'timeline-Tweet-author')[0]));}
times.push(getElementsByClassName(tmp[x],'dt-updated')[0]);permalinksURL.push(getElementsByClassName(tmp[x],'timeline-Tweet-timestamp')[0]);if(getElementsByClassName(tmp[x],'timeline-Tweet-media')[0]!==undefined){images.push(getElementsByClassName(tmp[x],'timeline-Tweet-media')[0]);}else{images.push(undefined);}}
x++;}}
if(tweets.length>maxTweets){tweets.splice(maxTweets,(tweets.length-maxTweets));authors.splice(maxTweets,(authors.length-maxTweets));times.splice(maxTweets,(times.length-maxTweets));rts.splice(maxTweets,(rts.length-maxTweets));images.splice(maxTweets,(images.length-maxTweets));permalinksURL.splice(maxTweets,(permalinksURL.length-maxTweets));}
var arrayTweets=[];var x=tweets.length;var n=0;if(dataOnly){while(n<x){arrayTweets.push({tweet:tweets[n].innerHTML,author:authors[n]?authors[n].innerHTML:'Unknown Author',author_data:{profile_url:authors[n]?authors[n].querySelector('[data-scribe="element:user_link"]').href:null,profile_image:authors[n]?authors[n].querySelector('[data-scribe="element:avatar"]').getAttribute('data-src-1x'):null,profile_image_2x:authors[n]?authors[n].querySelector('[data-scribe="element:avatar"]').getAttribute('data-src-2x'):null,screen_name:authors[n]?authors[n].querySelector('[data-scribe="element:screen_name"]').title:null,name:authors[n]?authors[n].querySelector('[data-scribe="element:name"]').title:null},time:times[n].textContent,timestamp:times[n].getAttribute('datetime').replace('+0000','Z').replace(/([\+\-])(\d\d)(\d\d)/,'$1$2:$3'),image:extractImageUrl(images[n]),rt:rts[n],tid:tids[n],permalinkURL:(permalinksURL[n]===undefined)?'':permalinksURL[n].href});n++;}}else{while(n<x){if(typeof(formatterFunction)!=='string'){var datetimeText=times[n].getAttribute('datetime');var newDate=new Date(times[n].getAttribute('datetime').replace(/-/g,'/').replace('T',' ').split('+')[0]);var dateString=formatterFunction(newDate,datetimeText);times[n].setAttribute('aria-label',dateString);if(tweets[n].textContent){if(supportsClassName){times[n].textContent=dateString;}else{var h=document.createElement('p');var t=document.createTextNode(dateString);h.appendChild(t);h.setAttribute('aria-label',dateString);times[n]=h;}}else{times[n].textContent=dateString;}}
var op='';if(parseLinks){if(targetBlank){targetLinksToNewWindow(tweets[n]);if(printUser){targetLinksToNewWindow(authors[n]);}}
if(printUser){op+='<div class="user">'+strip(authors[n].innerHTML)+'</div>';}
op+='<p class="tweet">'+strip(tweets[n].innerHTML)+'</p>';if(printTime){if(permalinks){op+='<p class="timePosted"><a href="'+permalinksURL[n]+'">'+times[n].getAttribute('aria-label')+'</a></p>';}else{op+='<p class="timePosted">'+
times[n].getAttribute('aria-label')+'</p>';}}}else{if(tweets[n].textContent){if(printUser){op+='<p class="user">'+authors[n].textContent+'</p>';}
op+='<p class="tweet">'+tweets[n].textContent+'</p>';if(printTime){op+='<p class="timePosted">'+times[n].textContent+'</p>';}}else{if(printUser){op+='<p class="user">'+authors[n].textContent+'</p>';}
op+='<p class="tweet">'+tweets[n].textContent+'</p>';if(printTime){op+='<p class="timePosted">'+times[n].textContent+'</p>';}}}
if(showInteractionLinks){op+='<p class="interact"><a href="https://twitter.com/intent/'+'tweet?in_reply_to='+tids[n]+'" class="twitter_reply_icon"'+
(targetBlank?' target="_blank">':'>')+'Reply</a><a href="https://twitter.com/intent/retweet?'+'tweet_id='+tids[n]+'" class="twitter_retweet_icon"'+
(targetBlank?' target="_blank">':'>')+'Retweet</a>'+'<a href="https://twitter.com/intent/favorite?tweet_id='+
tids[n]+'" class="twitter_fav_icon"'+
(targetBlank?' target="_blank">':'>')+'Favorite</a></p>';}
if(showImages&&images[n]!==undefined&&extractImageUrl(images[n])!==undefined){op+='<div class="media">'+'<img src="'+extractImageUrl(images[n])+'" alt="Image from tweet" />'+'</div>';}
if(showImages){arrayTweets.push(op);}else if(!showImages&&tweets[n].textContent.length){arrayTweets.push(op);}
n++;}}
handleTweets(arrayTweets);inProgress=false;if(queue.length>0){twitterFetcher.fetch(queue[0]);queue.splice(0,1);}}};window.__twttrf=twitterFetcher;window.twitterFetcher=twitterFetcher;return twitterFetcher;}));

;

window.FooterView = (function(superClass) {
  extend(FooterView, superClass);

  function FooterView() {
    return FooterView.__super__.constructor.apply(this, arguments);
  }

  FooterView.prototype.initialize = function() {
    return this._validate();
  };

  FooterView.prototype.update = function($el) {
    this.$el = $el;
    return this._validate();
  };

  FooterView.prototype._validate = function() {
    this.instagramToken = this.$(".footer-instagram").data('instagram-access-token');
    this.twitterId = this.$(".footer-tweet").data('twitter-id');
    this.twitterRetweets = this.$(".footer-tweet").data('twitter-retweets');
    if (this.$(".footer-instagram").length && this.instagramToken.length) {
      this.count = this.$(".footer-instagram").data('instagram-count') * 1;
      this.fetchInstagramPhotos();
    }
    if (this.$(".twitter-enabled").length) {
      return this.fetchTweets(this.twitterId, this.twitterRetweets);
    }
  };

  FooterView.prototype.fetchInstagramPhotos = function() {
    var url;
    url = "https://api.instagram.com/v1/users/self/media/recent?access_token=" + this.instagramToken + "&count=" + this.count + "&callback=?";
    return $.ajax(url, {
      type: "GET",
      dataType: "jsonp",
      timeout: 10000,
      error: (function(_this) {
        return function(jqXHR, textStatus) {
          _this.$(".footer-instagram").hide();
          console.log("Instagram Error: " + textStatus);
          if (textStatus === "timeout") {
            return console.log("A timeout error means that either the API is down or the merchant provided an incorrect User ID causing a 404.");
          }
        };
      })(this),
      success: (function(_this) {
        return function(query) {
          var i, image, j, len, photo, ref1, results, scale;
          if (_this.count === 3) {
            i = 2;
          } else {
            i = 5;
          }
          if (query.meta.code === 200) {
            ref1 = query.data.slice(0, +i + 1 || 9e9);
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              photo = ref1[j];
              image = photo.images.standard_resolution;
              scale = image.width > image.height ? 'y' : 'x';
              results.push(_this.$(".footer-instagram-photos").append("<div class=\"footer-instagram-photo\">\n    <a\n        class=\"instagram-link\"\n        href=\"" + photo.link + "\"\n        target=\"_blank\"\n    >\n        <img\n            class=\"\n                instagram-image\n                instagram-image-scale-" + scale + "\n            \"\n            src=\"" + image.url + "\"\n        />\n    </a>\n</div>"));
            }
            return results;
          } else {
            _this.$(".footer-instagram").hide();
            return console.log("Instagram Error: " + query.meta.error_message);
          }
        };
      })(this)
    });
  };

  FooterView.prototype.fetchTweets = function() {
    var config;
    config = {
      "profile": {
        "screenName": this.twitterId
      },
      "maxTweets": 1,
      "enableLinks": true,
      "showUser": true,
      "showTime": true,
      "showRetweet": this.twitterRetweets,
      "customCallback": this.renderTweets,
      "showInteraction": false
    };
    return twitterFetcher.fetch(config);
  };

  FooterView.prototype.renderTweets = function(tweets) {
    if (tweets.length) {
      return this.$(".footer-tweet").append("<span class='tweet-wrap'>" + tweets[0] + "</span>");
    } else {
      return console.log("No tweets to display. Most probably cause is an incorrectly entered Widget ID.");
    }
  };

  return FooterView;

})(Backbone.View);

window.AccountView = (function(superClass) {
  extend(AccountView, superClass);

  function AccountView() {
    return AccountView.__super__.constructor.apply(this, arguments);
  }

  AccountView.prototype.events = {
    "click .delete-address": "deleteAddress",
    "click .edit-address": "editAddress",
    "click .cancel-edit": "cancelEditing",
    "click .toggle-new-address": "toggleNewAddress",
    "click .toggle-forgetfulness span": "recoverPassword"
  };

  AccountView.prototype.initialize = function() {
    if ($(document.body).hasClass("template-customers-addresses")) {
      this.prepareAddresses();
    }
    if ($(document.body).hasClass("template-customers-login")) {
      this.checkForReset();
    }
    if (window.location.hash === "#recover") {
      return this.recoverPassword();
    }
  };

  AccountView.prototype.recoverPassword = function() {
    this.$(".recover-password").toggle();
    return this.$(".customer-login").toggle();
  };

  AccountView.prototype.checkForReset = function() {
    if ($(".reset-check").data("successful-reset") === true) {
      return $(".successful-reset").show();
    }
  };

  AccountView.prototype.prepareAddresses = function() {
    var address, addressID, addresses, j, len, results;
    new Shopify.CountryProvinceSelector("address-country", "address-province", {
      hideElement: "address-province-container"
    });
    addresses = this.$(".customer-address");
    if (addresses.length) {
      results = [];
      for (j = 0, len = addresses.length; j < len; j++) {
        address = addresses[j];
        addressID = $(address).data("address-id");
        results.push(new Shopify.CountryProvinceSelector("address-country-" + addressID, "address-province-" + addressID, {
          hideElement: "address-province-container-" + addressID
        }));
      }
      return results;
    }
  };

  AccountView.prototype.deleteAddress = function(e) {
    var addressID;
    addressID = $(e.target).parents("[data-address-id]").data("address-id");
    return Shopify.CustomerAddress.destroy(addressID);
  };

  AccountView.prototype.editAddress = function(e) {
    var addressID, modalContent;
    addressID = $(e.target).parents("[data-address-id]").data("address-id");
    modalContent = new ModalContent({
      title: false,
      message: false
    });
    return new ModalView({
      model: modalContent,
      el: this.$(".modal-wrapper[data-address-id='" + addressID + "']")
    });
  };

  AccountView.prototype.cancelEditing = function(e) {
    var addressID;
    addressID = $(e.target).parents("[data-address-id]").data("address-id");
    $(".customer-address[data-address-id='" + addressID + "']").removeClass("editing");
    return $(".customer-address-edit-form[data-address-id='" + addressID + "']").removeClass("show");
  };

  AccountView.prototype.toggleNewAddress = function() {
    this.$(".add-new-address").toggle();
    return this.$(".customer-new-address").toggleClass("show");
  };

  return AccountView;

})(Backbone.View);

window.CartView = (function(superClass) {
  extend(CartView, superClass);

  function CartView() {
    this.updateShippingLabel = bind(this.updateShippingLabel, this);
    return CartView.__super__.constructor.apply(this, arguments);
  }

  CartView.prototype.events = {
    "change .cart-item-quantity-display": "updateQuantity",
    "click .cart-item-decrease": "updateQuantity",
    "click .cart-item-increase": "updateQuantity",
    "click .remove span": "removeProduct",
    "click .cart-undo": "undoRemoval",
    "change .cart-instructions textarea": "saveSpecialInstructions",
    "click .cart-item-upload": "showFile",
    "click .get-rates": "onGetRates"
  };

  CartView.prototype.initialize = function(options) {
    this.sectionBinding();
    return this.render();
  };

  CartView.prototype.render = function() {
    this.section = window.sectionJSON;
    this.cartText = window.cartTextJSON;
    this.$shippingStrings = this.$('[data-shipping-calculator-strings]');
    this.transitionend = (function(transition) {
      var transEndEventNames;
      transEndEventNames = {
        "-webkit-transition": "webkitTransitionEnd",
        "-moz-transition": "transitionend",
        "-o-transition": "oTransitionEnd",
        transition: "transitionend"
      };
      return transEndEventNames[transition];
    })(Modernizr.prefixed("transition"));
    this.savedProducts = [];
    if (this.$shippingStrings.length) {
      this.shippingCalculator();
      if (Shop.customerLoggedIn && Shop.customerAddress && Shop.customerAddress.country.length && Shop.customerAddress.zip.length) {
        this.calculateShipping(true);
      }
      return Shopify.onError = (function(_this) {
        return function(XMLHttpRequest) {
          return _this.handleErrors(XMLHttpRequest);
        };
      })(this);
    }
  };

  CartView.prototype.sectionBinding = function() {
    this.$el.on('shopify:section:load', (function(_this) {
      return function(event) {
        if (!$(event.target).hasClass('section-cart')) {
          return;
        }
        _this.delegateEvents();
        return _this.render();
      };
    })(this));
    return this.$el.on('shopify:section:unload', (function(_this) {
      return function(event) {
        if (!$(event.target).hasClass('section-cart')) {
          return;
        }
        return _this.undelegateEvents();
      };
    })(this));
  };

  CartView.prototype.saveSpecialInstructions = function() {
    var newNote;
    newNote = $(".cart-instructions textarea").val();
    return Shopify.updateCartNote(newNote, function(cart) {});
  };

  CartView.prototype.updatePrice = function($el, price) {
    var attribute, j, len, ref1;
    ref1 = $el[0].attributes;
    for (j = 0, len = ref1.length; j < len; j++) {
      attribute = ref1[j];
      if (attribute.name.indexOf('data-currency') > -1) {
        $el.attr(attribute.name, '');
      }
    }
    return $el.html(price).attr("data-currency-" + Shop.currency, price).attr('data-currency', Shop.currency);
  };

  CartView.prototype.updateQuantity = function(e) {
    var $productPrice, $productQuantity, $productRow, newQuantity, oldQuantity, variant;
    $productRow = $(e.target).parents('tr');
    $productPrice = $productRow.find('.cart-item-total .money');
    $productQuantity = $productRow.find('.cart-item-quantity-display');
    oldQuantity = parseInt($productQuantity.val());
    oldQuantity = isNaN(oldQuantity) ? 1 : oldQuantity;
    if ($(e.target).hasClass('cart-item-quantity-display')) {
      newQuantity = oldQuantity;
    } else if ($(e.target).hasClass('cart-item-increase')) {
      newQuantity = oldQuantity + 1;
    } else if ($(e.target).hasClass('cart-item-decrease')) {
      newQuantity = Math.max(oldQuantity - 1, 0);
    }
    variant = $productRow.data('variant');
    if (newQuantity === 0) {
      this.removeProduct(null, variant);
      return;
    }
    $productQuantity.val(newQuantity);
    return Shopify.changeItem(variant, newQuantity, (function(_this) {
      return function(cart) {
        var cartItem, cartItemQuantity, item, modalContent, modalMessage, newProductPrice;
        cartItem = cart.items.filter(function(item) {
          return item.id === variant;
        });
        item = cartItem[0];
        newProductPrice = Shopify.formatMoney(item.line_price, Shop.moneyFormat);
        cartItemQuantity = item.quantity;
        _this.updatePrice($productPrice, newProductPrice);
        $productQuantity.val(cartItemQuantity);
        if (cartItemQuantity !== newQuantity) {
          modalMessage = Shop.cartQuantityError.message.replace('** quantity **', cartItemQuantity).replace('** title **', item.title);
          modalContent = new ModalContent({
            title: Shop.cartQuantityError.title,
            message: "<p>" + modalMessage + "</p>",
            button: Shop.cartQuantityError.button
          });
          new ModalView({
            model: modalContent,
            el: _this.$('.modal-wrapper')
          });
        }
        return _this.updateCart(cart);
      };
    })(this));
  };

  CartView.prototype.removeProduct = function(e, variant) {
    var itemRow, itemRowContents, productTitle, productURL, showUndo;
    if (variant) {
      itemRow = $(".variant-" + variant);
    } else {
      variant = $(e.target).parents("tr").data("variant");
      itemRow = $(e.target).parents("tr");
    }
    itemRowContents = itemRow.find("td");
    productTitle = itemRow.data("title");
    productURL = itemRow.data("url");
    this.savedProducts[variant] = {
      "id": variant,
      "content": itemRowContents,
      "quantity": itemRow.find("td.quantity input").val()
    };
    showUndo = (function(_this) {
      return function() {
        var itemRemovedText;
        itemRemovedText = "{{ 'cart.item_removed_message' | t | escape }}".replace("{% raw %}{{ item_title }}{% endraw %}", "<a href='" + productURL + "'>" + productTitle + "</a>");
        itemRow.html("<td colspan='5'>" + itemRemovedText + " <span class='cart-undo' data-variant='" + variant + "'>{{ 'cart.undo' | t | escape }}</span>");
        return itemRow.removeClass("removing");
      };
    })(this);
    return Shopify.removeItem(variant, (function(_this) {
      return function(cart) {
        if (Modernizr.csstransitions) {
          itemRow.addClass("removing").one(_this.transitionend, function() {
            return showUndo();
          });
        } else {
          showUndo();
        }
        return _this.updateCart(cart);
      };
    })(this));
  };

  CartView.prototype.undoRemoval = function(e) {
    var savedProduct, variant;
    variant = $(e.target).data("variant");
    savedProduct = this.savedProducts[variant];
    $("tr.variant-" + variant).html(savedProduct.content);
    return Shopify.addItem(variant, savedProduct.quantity, (function(_this) {
      return function() {
        return Shopify.getCart(function(cart) {
          return _this.updateCart(cart);
        });
      };
    })(this));
  };

  CartView.prototype.updateCart = function(cart) {
    var cartCount, cartCountText, newTotal;
    newTotal = Shopify.formatMoney(cart.total_price, Shop.moneyFormat);
    this.updatePrice(this.$('.cart-checkout .cart-price .money'), newTotal);
    if (Shop.currencySwitcher) {
      $('.currency-switcher').trigger('switch-currency');
    }
    cartCount = cart.item_count;
    cartCountText = cart.item_count === 1 ? this.cartText[0] : this.cartText[1];
    $(".bag-count").text(cartCount);
    return $(".bag-text").text(cartCountText);
  };

  CartView.prototype.showFile = function(e) {
    var file, image, modalContent;
    file = $(e.target).data("file");
    if (file.match(/(jpg|jpeg|png|gif)/)) {
      image = "<img alt='' src='" + file + "'>";
      modalContent = new ModalContent({
        title: $(e.target).prev().text(),
        message: image
      });
      return new ModalView({
        model: modalContent,
        el: this.$(".modal-wrapper")
      });
    }
  };

  CartView.prototype.shippingCalculator = function() {
    var selectableOptions;
    Shopify.Cart.ShippingCalculator.show({
      submitButton: "{{ 'cart.shipping_calculator.submit' | t | escape }}",
      submitButtonDisabled: "{{ 'cart.shipping_calculator.disabled' | t | escape }}",
      customerIsLoggedIn: Shop.customerLoggedIn,
      moneyFormat: Shop.moneyFormat
    });
    selectableOptions = this.$(".cart-shipping-calculator select");
    setTimeout((function(_this) {
      return function() {
        var j, len, results, select;
        results = [];
        for (j = 0, len = selectableOptions.length; j < len; j++) {
          select = selectableOptions[j];
          results.push(_this.updateShippingLabel(select));
        }
        return results;
      };
    })(this), 500);
    return this.$(".cart-shipping-calculator select").change((function(_this) {
      return function(e) {
        var j, len, results, select;
        results = [];
        for (j = 0, len = selectableOptions.length; j < len; j++) {
          select = selectableOptions[j];
          results.push(_this.updateShippingLabel(select));
        }
        return results;
      };
    })(this));
  };

  CartView.prototype.onGetRates = function() {
    return this.calculateShipping();
  };

  CartView.prototype.calculateShipping = function(auto) {
    var shippingAddress;
    this.$(".get-rates").val("{{ 'cart.shipping_calculator.disabled' | t | escape }}");
    if (auto) {
      shippingAddress = Shop.customerAddress;
    } else {
      shippingAddress = {};
      shippingAddress.zip = this.$(".address-zip").val() || "";
      shippingAddress.country = this.$(".address-country").val() || "";
      shippingAddress.province = this.$(".address-province").val() || "";
    }
    return Shopify.getCartShippingRatesForDestination(shippingAddress, function(rates) {
      var address, feedback, firstRate, j, len, price, rate, rateValues, ratesFeedback, response, shippingCalculatorResponse;
      address = shippingAddress.zip + ", " + shippingAddress.province + ", " + shippingAddress.country;
      if (!shippingAddress.province.length) {
        address = shippingAddress.zip + ", " + shippingAddress.country;
      }
      if (!shippingAddress.zip.length) {
        address = shippingAddress.province + ", " + shippingAddress.country;
      }
      if (!(shippingAddress.province.length && shippingAddress.zip.length)) {
        address = shippingAddress.country;
      }
      shippingCalculatorResponse = this.$(".cart-shipping-calculator-response");
      shippingCalculatorResponse.empty().append("<p class='shipping-calculator-response message'/><ul class='shipping-rates'/>");
      ratesFeedback = $(".shipping-calculator-response");
      if (rates.length > 1) {
        firstRate = Shopify.Cart.ShippingCalculator.formatRate(rates[0].price);
        feedback = "{{ 'cart.shipping_calculator.rates_html' | t | escape }}".replace("{% raw %}{{ address }}{% endraw %}", address).replace("{% raw %}{{ number_of_rates }}{% endraw %}", rates.length).replace("{% raw %}{{ rate }}{% endraw %}", "<span class='money'>" + firstRate + "</span>");
        ratesFeedback.html(feedback);
      } else if (rates.length === 1) {
        response = "{{ 'cart.shipping_calculator.rate' | t | escape }}".replace("{% raw %}{{ address }}{% endraw %}", address);
        ratesFeedback.html(response);
      } else {
        ratesFeedback.html("{{ 'cart.shipping_calculator.no_rates' | t | escape }}");
      }
      for (j = 0, len = rates.length; j < len; j++) {
        rate = rates[j];
        price = Shopify.Cart.ShippingCalculator.formatRate(rate.price);
        rateValues = "{{ 'cart.shipping_calculator.rate_values_html' | t | escape }}".replace("{% raw %}{{ rate_title }}{% endraw %}", rate.name).replace("{% raw %}{{ rate }}{% endraw %}", "<span class='money'>" + price + "</span>");
        this.$(".shipping-rates").append("<li>" + rateValues + "</li>");
      }
      return this.$(".get-rates").val("{{ 'cart.shipping_calculator.submit' | t | escape }}");
    });
  };

  CartView.prototype.handleErrors = function(errors) {
    var errorMessage;
    errorMessage = $.parseJSON(errors.responseText);
    errorMessage = "{{ 'cart.shipping_calculator.error' | t | escape }}".replace("{% raw %}{{ error_message }}{% endraw %}", errorMessage.zip);
    this.$(".cart-shipping-calculator-response").html("<p class='error'>" + errorMessage + "</p>");
    return this.$(".get-rates").val("{{ 'cart.shipping_calculator.submit' | t | escape }}");
  };

  CartView.prototype.updateShippingLabel = function(select) {
    var selectedOption;
    if (select) {
      select = $(select);
      selectedOption = select.find("option:selected").val();
      if (!selectedOption || selectedOption === '---') {
        selectedOption = select.data("default");
        select.val(selectedOption);
      }
      select.prev(".selected-text").text(selectedOption);
      return setTimeout((function(_this) {
        return function() {
          if (select.attr("name") === "address[country]") {
            return _this.updateShippingLabel(_this.$("#address_province"));
          }
        };
      })(this), 1500);
    }
  };

  return CartView;

})(Backbone.View);

window.ModalContent = (function(superClass) {
  extend(ModalContent, superClass);

  function ModalContent() {
    return ModalContent.__super__.constructor.apply(this, arguments);
  }

  ModalContent.prototype.defaults = {
    title: "",
    message: "",
    button: false
  };

  return ModalContent;

})(Backbone.Model);

window.ModalView = (function(superClass) {
  extend(ModalView, superClass);

  function ModalView() {
    return ModalView.__super__.constructor.apply(this, arguments);
  }

  ModalView.prototype.events = {
    "click .modal-close": "closeModal"
  };

  ModalView.prototype.initialize = function() {
    this.content = this.model.toJSON();
    this.body = $(document.body);
    this.transitionend = (function(transition) {
      var transEndEventNames;
      transEndEventNames = {
        "-webkit-transition": "webkitTransitionEnd",
        "-moz-transition": "transitionend",
        "-o-transition": "oTransitionEnd",
        transition: "transitionend"
      };
      return transEndEventNames[transition];
    })(Modernizr.prefixed("transition"));
    this.enterContent();
    return this.openModal();
  };

  ModalView.prototype.enterContent = function() {
    if (this.content.title) {
      this.$(".modal-title").text(this.content.title);
    }
    if (this.content.message) {
      this.$(".modal-message").html(this.content.message);
    }
    if (this.content.button) {
      return this.$(".modal-message").append("<p><span class='modal-close button'>" + this.content.button + "</span></p>");
    }
  };

  ModalView.prototype.centerModal = function() {
    var modalContentHeight, modalContentWidth;
    modalContentHeight = this.$(".modal-content").outerHeight();
    modalContentWidth = this.$(".modal-content").outerWidth();
    if (modalContentHeight > $(window).height()) {
      this.$(".modal-content").css({
        marginTop: 0,
        marginLeft: -(modalContentWidth / 2)
      });
      return this.body.addClass("modal-overflow");
    } else {
      this.$(".modal-content").css({
        marginTop: -(modalContentHeight / 2),
        marginLeft: -(modalContentWidth / 2)
      });
      return this.body.removeClass("modal-overflow");
    }
  };

  ModalView.prototype.openModal = function() {
    var checkImagesLoaded;
    this.$el.addClass("active");
    setTimeout((function(_this) {
      return function() {
        return _this.$el.addClass("opening");
      };
    })(this), 20);
    checkImagesLoaded = (function(_this) {
      return function() {
        return _this.$el.imagesLoaded(function() {
          _this.centerModal();
          $(window).on("resize", _.debounce(_this.centerModal, 50));
          return _this.$el.addClass("open");
        });
      };
    })(this);
    if (Modernizr.csstransitions) {
      this.$el.one(this.transitionend, (function(_this) {
        return function() {
          return checkImagesLoaded();
        };
      })(this));
    } else {
      checkImagesLoaded();
    }
    return this.body.on("keyup.modal", (function(_this) {
      return function(e) {
        if (e && e.type === "keyup" && e.keyCode === 27) {
          return _this.closeModal();
        }
      };
    })(this));
  };

  ModalView.prototype.closeModal = function() {
    var finishClosing;
    this.body.off("keyup.modal");
    this.$el.removeClass("open");
    this.$(".modal-content").one(this.transitionend, (function(_this) {
      return function(e) {
        return _this.$el.removeClass("opening");
      };
    })(this));
    finishClosing = (function(_this) {
      return function() {
        _this.$(".modal-content").unbind();
        _this.$el.unbind();
        _this.unbind();
        _this.body.removeClass("modal-overflow");
        return _this.$el.removeClass("active");
      };
    })(this);
    if (Modernizr.csstransitions) {
      this.$(".modal-content").one(this.transitionend, (function(_this) {
        return function(e) {
          return _this.$el.removeClass("opening");
        };
      })(this));
      return this.$el.on(this.transitionend, (function(_this) {
        return function(e) {
          if ($(e.target).hasClass("modal-wrapper")) {
            return finishClosing();
          }
        };
      })(this));
    } else {
      this.$el.removeClass("opening");
      return finishClosing();
    }
  };

  return ModalView;

})(Backbone.View);

window.CollectionView = (function(superClass) {
  extend(CollectionView, superClass);

  function CollectionView() {
    return CollectionView.__super__.constructor.apply(this, arguments);
  }

  CollectionView.prototype.events = {
    "change .collection-filter select": "updateFilter",
    "change .collection-sorting select": "sortProducts",
    "click .collection-remove-filter": "resetFilter",
    "click .collection-description-more": "createModal",
    "click .collection-sharing-toggle": "toggleSharing",
    "mouseout .share-buttons": "toggleSharing"
  };

  CollectionView.prototype.initialize = function() {
    this.sectionBinding();
    return this.validate();
  };

  CollectionView.prototype.validate = function() {
    this.section = window.sectionJSON;
    this.tagsWrapper = this.$(".collection-tags-wrapper");
    this.tags = this.tagsWrapper.find(".collection-tags");
    this.tagFilter = this.$(".collection-tags-apply");
    if ($("html").hasClass("lt-ie9") && this.$(".collection-header").length) {
      this.verticallyAlignHeaderText();
    }
    if (this.section.collection_filtering) {
      this.filterProducts();
    }
    if ($(".collection-products").data("layout") === "masonry") {
      return this.masonryLayout();
    }
  };

  CollectionView.prototype.sectionBinding = function() {
    this.$el.on('shopify:section:load', (function(_this) {
      return function(event) {
        if (!$(event.target).hasClass('section-collection')) {
          return;
        }
        _this.delegateEvents();
        return _this.validate();
      };
    })(this));
    return this.$el.on('shopify:section:unload', (function(_this) {
      return function(event) {
        if (!$(event.target).hasClass('section-collection')) {
          return;
        }
        return _this.undelegateEvents();
      };
    })(this));
  };

  CollectionView.prototype.verticallyAlignHeaderText = function() {
    var headerHeight;
    headerHeight = this.$(".collection-details").height();
    return this.$(".collection-details").css({
      marginTop: -(headerHeight / 2)
    });
  };

  CollectionView.prototype.toggleSharing = function(e) {
    if (e.type === "mouseout") {
      if ($(e.relatedTarget).closest(".share-buttons").length) {
        return;
      }
    }
    return this.$(".collection-sharing").toggleClass("active");
  };

  CollectionView.prototype.sortProducts = function(e) {
    var Sorting, currentSearch, index, j, len, part, search, searchParts;
    Sorting = {};
    Sorting.sort_by = this.$(".collection-sorting select").val();
    if ($(e.target).closest(".collection-sorting").hasClass("vendor-collection")) {
      currentSearch = location.search;
      searchParts = currentSearch.split("&");
      for (index = j = 0, len = searchParts.length; j < len; index = ++j) {
        part = searchParts[index];
        if (part.indexOf("sort_by") !== -1) {
          searchParts.splice(index, 1);
        }
      }
      search = searchParts.join("&");
      return location.search = search + "&" + (jQuery.param(Sorting));
    } else {
      return location.search = jQuery.param(Sorting);
    }
  };

  CollectionView.prototype.masonryLayout = function() {
    var products;
    products = this.$(".collection-products");
    if (this.$(".product-list-item").length) {
      return products.imagesLoaded((function(_this) {
        return function() {
          var masonry;
          products.masonry({
            transitionDuration: 0
          });
          masonry = products.data("masonry");
          masonry.on("layoutComplete", products.addClass("processed"));
          return masonry.off("layoutComplete");
        };
      })(this));
    } else {
      return products.addClass("processed empty-collection");
    }
  };

  CollectionView.prototype.filterProducts = function() {
    var filter, j, len, ref1, results, selectedText;
    this.fallbackURL = this.$(".collection-filtering").data("fallback-url");
    ref1 = this.$(".collection-filter select");
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      filter = ref1[j];
      if ($(filter).val() !== "any") {
        selectedText = $(filter).find("option:selected").text();
        results.push($(filter).prev().find("strong").text(selectedText));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  CollectionView.prototype.updateFilter = function(e) {
    var filter, filterURL, j, len, newTags, ref1, tag, tags;
    newTags = [];
    $(e.target).toggleClass("active");
    ref1 = this.$(".collection-filter select");
    for (j = 0, len = ref1.length; j < len; j++) {
      filter = ref1[j];
      if ($(filter).val() !== "any") {
        tag = $(filter).val();
        newTags.push(tag);
      }
    }
    if (newTags.length) {
      tags = newTags.join("+");
      filterURL = this.fallbackURL + "/" + tags;
      return window.location.href = filterURL;
    } else {
      return this.resetFilter();
    }
  };

  CollectionView.prototype.resetFilter = function() {
    var fallback;
    fallback = "" + this.fallbackURL + location.search;
    return window.location.href = fallback;
  };

  CollectionView.prototype.createModal = function() {
    var modalContent;
    modalContent = new ModalContent({
      "title": collectionJSON.title,
      "message": collectionJSON.body_html
    });
    return new ModalView({
      model: modalContent,
      el: this.$(".modal-wrapper")
    });
  };

  return CollectionView;

})(Backbone.View);

window.VideoView = (function(superClass) {
  extend(VideoView, superClass);

  function VideoView() {
    return VideoView.__super__.constructor.apply(this, arguments);
  }

  VideoView.prototype.events = {
    "click .home-video-play-button": "openVideo",
    "keyup": "closeVideo"
  };

  VideoView.prototype.initialize = function() {
    this.initializedClass = 'video-initialized';
    return this._validate();
  };

  VideoView.prototype.update = function($el) {
    this.$el = $el;
    return this._validate();
  };

  VideoView.prototype._validate = function() {
    if (this.$(".home-video").length) {
      this.videoWrapper = this.$(".home-video-embed-wrapper");
      this.video = this.$(".home-video-embed");
      this.detachedVideo = null;
    }
    if ($("html").hasClass("lt-ie9")) {
      this.centerVideoText();
    }
    if (this.$("[data-vimeo-image]").length) {
      this.loadVimeoThumbnail();
    }
    return this.transitionend = (function(transition) {
      var transEndEventNames;
      transEndEventNames = {
        "-webkit-transition": "webkitTransitionEnd",
        "-moz-transition": "transitionend",
        "-o-transition": "oTransitionEnd",
        transition: "transitionend"
      };
      return transEndEventNames[transition];
    })(Modernizr.prefixed("transition"));
  };

  VideoView.prototype.openVideo = function() {
    this.videoWrapper.addClass("opening");
    if (this.detachedVideo) {
      this.video.width("");
      this.detachedVideo.appendTo(this.video);
    } else {
      this.video.fitVids({
        customSelector: "iframe"
      });
    }
    this.verticallyCenterVideo();
    $(window).on("resize.video", (function(_this) {
      return function() {
        return _this.verticallyCenterVideo();
      };
    })(this));
    this.videoWrapper.on("click.video", (function(_this) {
      return function() {
        return _this.closeVideo();
      };
    })(this));
    return setTimeout((function(_this) {
      return function() {
        return _this.videoWrapper.addClass("open");
      };
    })(this), 20);
  };

  VideoView.prototype.centerVideoText = function() {
    var contentHeight, contentWidth, videoContent;
    videoContent = this.$(".home-video-content");
    contentWidth = videoContent.outerWidth();
    contentHeight = videoContent.outerHeight();
    return videoContent.css({
      marginTop: -(contentHeight / 2),
      marginLeft: -(contentWidth / 2)
    });
  };

  VideoView.prototype.verticallyCenterVideo = function() {
    var availableHeight, video, videoHeight, videoRatio, windowHeight;
    this.video.css({
      marginTop: 0,
      width: "100%"
    });
    video = this.video.find(".fluid-width-video-wrapper");
    videoHeight = video.outerHeight();
    videoRatio = video.width() / videoHeight;
    windowHeight = window.innerHeight || $(window).height();
    availableHeight = windowHeight - 60;
    if (videoHeight > availableHeight) {
      return this.video.removeClass("centered").css({
        marginTop: 0,
        width: availableHeight * videoRatio
      });
    } else {
      return this.video.addClass("centered").css({
        marginTop: -(videoHeight / 2),
        width: "100%"
      });
    }
  };

  VideoView.prototype.loadVimeoThumbnail = function() {
    return $.getJSON("http://vimeo.com/api/v2/video/" + (this.$('[data-vimeo-image]').data('vimeo-image')) + ".json?callback=?", (function(_this) {
      return function(data) {
        return _this.$('[data-vimeo-image]').attr('src', data[0].thumbnail_large);
      };
    })(this));
  };

  VideoView.prototype.closeVideo = function(e) {
    var detach;
    if (!this.$(".home-video").length) {
      return;
    }
    if (e && this.videoWrapper.hasClass("open")) {
      if (e.which !== 27) {
        return;
      }
    }
    $(window).off("resize.video");
    this.videoWrapper.off("click.video");
    this.videoWrapper.removeClass("open");
    detach = (function(_this) {
      return function() {
        _this.detachedVideo = _this.video.find(".fluid-width-video-wrapper").detach();
        return _this.videoWrapper.removeClass("opening").off(_this.transitionend);
      };
    })(this);
    if (Modernizr.csstransitions) {
      this.videoWrapper.on(this.transitionend, (function(_this) {
        return function() {
          return detach();
        };
      })(this));
      return setTimeout((function(_this) {
        return function() {
          if (_this.videoWrapper.hasClass("opening")) {
            return detach();
          }
        };
      })(this), 300);
    } else {
      return detach();
    }
  };

  return VideoView;

})(Backbone.View);

window.FeaturedImagesView = (function(superClass) {
  extend(FeaturedImagesView, superClass);

  function FeaturedImagesView() {
    return FeaturedImagesView.__super__.constructor.apply(this, arguments);
  }

  FeaturedImagesView.prototype.initialize = function() {
    this.initializedClass = 'featured-images-initialized';
    return this._validate();
  };

  FeaturedImagesView.prototype.update = function($el) {
    this.$el = $el;
    return this._validate();
  };

  FeaturedImagesView.prototype._validate = function() {
    var feature, j, len, ref1;
    if ($("html").hasClass("lt-ie9")) {
      ref1 = this.$(".home-feature");
      for (j = 0, len = ref1.length; j < len; j++) {
        feature = ref1[j];
        if ($(feature).find(".home-feature-content").length) {
          this.verticallyAlignContent($(feature).find(".home-feature-content"));
        }
      }
    }
    return this.transitionend = (function(transition) {
      var transEndEventNames;
      transEndEventNames = {
        "-webkit-transition": "webkitTransitionEnd",
        "-moz-transition": "transitionend",
        "-o-transition": "oTransitionEnd",
        transition: "transitionend"
      };
      return transEndEventNames[transition];
    })(Modernizr.prefixed("transition"));
  };

  FeaturedImagesView.prototype.verticallyAlignContent = function(content) {
    var contentHeight;
    content = $(content);
    contentHeight = content.outerHeight();
    return content.css({
      marginTop: -(contentHeight / 2)
    });
  };

  return FeaturedImagesView;

})(Backbone.View);

window.FeaturedProductsView = (function(superClass) {
  extend(FeaturedProductsView, superClass);

  function FeaturedProductsView() {
    return FeaturedProductsView.__super__.constructor.apply(this, arguments);
  }

  FeaturedProductsView.prototype.initialize = function() {
    this.initializedClass = 'featured-products-initialized';
    return this._validate();
  };

  FeaturedProductsView.prototype.update = function($el) {
    this.$el = $el;
    return this._validate();
  };

  FeaturedProductsView.prototype._validate = function() {
    return this.transitionend = (function(transition) {
      var transEndEventNames;
      transEndEventNames = {
        "-webkit-transition": "webkitTransitionEnd",
        "-moz-transition": "transitionend",
        "-o-transition": "oTransitionEnd",
        transition: "transitionend"
      };
      return transEndEventNames[transition];
    })(Modernizr.prefixed("transition"));
  };

  return FeaturedProductsView;

})(Backbone.View);

window.FeaturedCollectionsView = (function(superClass) {
  extend(FeaturedCollectionsView, superClass);

  function FeaturedCollectionsView() {
    return FeaturedCollectionsView.__super__.constructor.apply(this, arguments);
  }

  FeaturedCollectionsView.prototype.initialize = function() {
    this.initializedClass = 'featured-collections-initialized';
    return this._validate();
  };

  FeaturedCollectionsView.prototype.update = function($el) {
    this.$el = $el;
    return this._validate();
  };

  FeaturedCollectionsView.prototype._validate = function() {
    var collection, j, len, ref1;
    if ($("html").hasClass("lt-ie9")) {
      ref1 = this.$(".home-collection-list-item");
      for (j = 0, len = ref1.length; j < len; j++) {
        collection = ref1[j];
        this.verticallyAlignContent($(collection).find(".home-collection-list-item-content"));
      }
    }
    return this.transitionend = (function(transition) {
      var transEndEventNames;
      transEndEventNames = {
        "-webkit-transition": "webkitTransitionEnd",
        "-moz-transition": "transitionend",
        "-o-transition": "oTransitionEnd",
        transition: "transitionend"
      };
      return transEndEventNames[transition];
    })(Modernizr.prefixed("transition"));
  };

  FeaturedCollectionsView.prototype.verticallyAlignContent = function(content) {
    var contentHeight;
    content = $(content);
    contentHeight = content.outerHeight();
    return content.css({
      marginTop: -(contentHeight / 2)
    });
  };

  return FeaturedCollectionsView;

})(Backbone.View);

window.ListCollectionsView = (function(superClass) {
  extend(ListCollectionsView, superClass);

  function ListCollectionsView() {
    return ListCollectionsView.__super__.constructor.apply(this, arguments);
  }

  ListCollectionsView.prototype.initialize = function() {
    this.sectionBinding();
    return this.validate();
  };

  ListCollectionsView.prototype.validate = function() {
    if ($("html").hasClass("lt-ie9")) {
      return this.verticallyAlignDetails();
    }
  };

  ListCollectionsView.prototype.sectionBinding = function() {
    this.$el.on('shopify:section:load', (function(_this) {
      return function(event) {
        if (!$(event.target).hasClass('section-collections-list')) {
          return;
        }
        _this.delegateEvents();
        return _this.validate();
      };
    })(this));
    return this.$el.on('shopify:section:unload', (function(_this) {
      return function(event) {
        if (!$(event.target).hasClass('section-collections-list')) {
          return;
        }
        return _this.undelegateEvents();
      };
    })(this));
  };

  ListCollectionsView.prototype.verticallyAlignDetails = function() {
    return this.$(".collections-list").imagesLoaded((function(_this) {
      return function() {
        var collection, collectionDetailsHeight, collectionsDetails, j, len, ref1, results;
        ref1 = _this.$(".collection-item");
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          collection = ref1[j];
          collectionsDetails = $(collection).find(".collection-item-details");
          collectionDetailsHeight = collectionsDetails.height();
          results.push(collectionsDetails.css({
            marginTop: -(collectionDetailsHeight / 2)
          }));
        }
        return results;
      };
    })(this));
  };

  return ListCollectionsView;

})(Backbone.View);

window.PasswordView = (function(superClass) {
  extend(PasswordView, superClass);

  function PasswordView() {
    return PasswordView.__super__.constructor.apply(this, arguments);
  }

  PasswordView.prototype.events = {
    "click .password-entry": "togglePasswordForm"
  };

  PasswordView.prototype.initialize = function() {
    this.toggle = this.$(".password-entry");
    if (this.$("[data-password-form-inner]").hasClass("has-errors")) {
      return this.togglePasswordForm();
    }
  };

  PasswordView.prototype.togglePasswordForm = function() {
    this.$(".password-subscribe-wrapper").add(".password-form-wrapper").toggleClass("visible");
    if (this.$(".password-subscribe-wrapper").hasClass("visible")) {
      return this.toggle.text(this.toggle.data("enter-password"));
    } else {
      return this.toggle.text(this.toggle.data("cancel"));
    }
  };

  return PasswordView;

})(Backbone.View);

window.ImageZoomView = (function(superClass) {
  extend(ImageZoomView, superClass);

  function ImageZoomView() {
    return ImageZoomView.__super__.constructor.apply(this, arguments);
  }

  ImageZoomView.prototype.events = {
    "prepare-zoom": "prepareZoom",
    "click": "toggleZoom",
    "mouseout .product-zoom": "toggleZoom",
    "mousemove .product-zoom": "zoomImage"
  };

  ImageZoomView.prototype.initialize = function() {
    this.zoomArea = this.$(".product-zoom");
    this.prepareZoom();
    return $(window).resize((function(_this) {
      return function() {
        return _this.prepareZoom();
      };
    })(this));
  };

  ImageZoomView.prototype.prepareZoom = function() {
    var newImage, photoAreaHeight, photoAreaWidth;
    photoAreaWidth = this.$el.width();
    photoAreaHeight = this.$el.height();
    newImage = new Image();
    $(newImage).on("load", (function(_this) {
      return function() {
        var ratio, ratios;
        _this.zoomImageWidth = newImage.width;
        _this.zoomImageHeight = newImage.height;
        ratios = new Array();
        ratios[0] = _this.zoomImageWidth / photoAreaWidth;
        ratios[1] = _this.zoomImageHeight / photoAreaHeight;
        ratio = Math.max.apply(Math, ratios);
        if (ratio < 1.4) {
          _this.$el.removeClass("zoom-enabled");
        } else {
          _this.$el.addClass("zoom-enabled");
          return _this.zoomArea.css({
            backgroundImage: "url(" + newImage.src + ")"
          });
        }
      };
    })(this));
    return newImage.src = this.$("img").attr("src");
  };

  ImageZoomView.prototype.toggleZoom = function(e) {
    if (this.$el.hasClass("zoom-enabled")) {
      if (e.type === "mouseout") {
        this.zoomArea.removeClass("active");
        return;
      }
      if (this.zoomArea.hasClass("active")) {
        this.zoomArea.removeClass("active");
      } else {
        this.zoomArea.addClass("active");
      }
      return this.zoomImage(e);
    }
  };

  ImageZoomView.prototype.zoomImage = function(e) {
    var bigImageOffset, bigImageX, bigImageY, mousePositionX, mousePositionY, newBackgroundPosition, ratioX, ratioY, zoomHeight, zoomWidth;
    zoomWidth = this.zoomArea.width();
    zoomHeight = this.zoomArea.height();
    bigImageOffset = this.$el.offset();
    bigImageX = Math.round(bigImageOffset.left);
    bigImageY = Math.round(bigImageOffset.top);
    mousePositionX = e.pageX - bigImageX;
    mousePositionY = e.pageY - bigImageY;
    if (mousePositionX < zoomWidth && mousePositionY < zoomHeight && mousePositionX > 0 && mousePositionY > 0) {
      if (this.zoomArea.hasClass("active")) {
        ratioX = Math.round(mousePositionX / zoomWidth * this.zoomImageWidth - zoomWidth / 2) * -1;
        ratioY = Math.round(mousePositionY / zoomHeight * this.zoomImageHeight - zoomHeight / 2) * -1;
        if (ratioX > 0) {
          ratioX = 0;
        }
        if (ratioY > 0) {
          ratioY = 0;
        }
        if (ratioX < -(this.zoomImageWidth - zoomWidth)) {
          ratioX = -(this.zoomImageWidth - zoomWidth);
        }
        if (ratioY < -(this.zoomImageHeight - zoomHeight)) {
          ratioY = -(this.zoomImageHeight - zoomHeight);
        }
        newBackgroundPosition = ratioX + "px " + ratioY + "px";
        return this.zoomArea.css({
          backgroundPosition: newBackgroundPosition
        });
      }
    }
  };

  return ImageZoomView;

})(Backbone.View);

window.RTEView = (function(superClass) {
  extend(RTEView, superClass);

  function RTEView() {
    return RTEView.__super__.constructor.apply(this, arguments);
  }

  RTEView.prototype.events = {
    "change .select-wrapper select": "updateOption"
  };

  RTEView.prototype.initialize = function() {
    var j, len, results, select, selects;
    this.setupTabs();
    this.$el.fitVids({
      customSelector: "iframe",
      ignore: "[data-shop='embeds.myshopify.com']"
    });
    selects = this.$("select");
    results = [];
    for (j = 0, len = selects.length; j < len; j++) {
      select = selects[j];
      if (!$(select).parent(".select-wrapper").length) {
        $(select).wrap('<div class="select-wrapper" />').parent().prepend("<span class='selected-text'></span>");
      }
      results.push(this.updateOption(null, select));
    }
    return results;
  };

  RTEView.prototype.setupTabs = function() {
    var groupedContent;
    return groupedContent = new GroupedContent(this.$el.get(0), {
      layout: 'tabs',
      intelliparse: false
    });
  };

  RTEView.prototype.updateOption = function(e, selector) {
    var newOption, select;
    select = e ? $(e.target) : $(selector);
    newOption = select.find("option:selected").text();
    return select.siblings(".selected-text").text(newOption);
  };

  return RTEView;

})(Backbone.View);

ProductView = (function() {
  function ProductView(options) {
    var j, len, ref1, rte;
    this.el = options.el;
    this.$el = $(options.el);
    this.data = options.data;
    this.sectionBinding();
    this.validate();
    this.bindEvents();
    this.images = JSON.parse($("[data-images]", this.$el).text());
    ref1 = this.$el.find(".rte");
    for (j = 0, len = ref1.length; j < len; j++) {
      rte = ref1[j];
      new RTEView({
        el: rte
      });
    }
    if (Shop.currencySwitcher) {
      $('.currency-switcher').trigger('switch-currency');
    }
  }

  ProductView.prototype.bindEvents = function() {
    this.$el.find('.product-options select').on("change", (function(_this) {
      return function(e) {
        return _this.updateVariantLabel(e, $(_this));
      };
    })(this));
    this.$el.find('.product-thumbnails img').on("click", (function(_this) {
      return function(e) {
        return _this.swapImage(e, $(_this));
      };
    })(this));
    return this.$el.find('.product-form').on("submit", (function(_this) {
      return function(e) {
        return _this.addToCart(e);
      };
    })(this));
  };

  ProductView.prototype.validate = function() {
    var $productJSON, $productSettings;
    this.settings = this.data.settings;
    this.product = this.data.product;
    this.section = this.data.section;
    this.cartText = this.data.cartText;
    this.zoomEnabled = this.section.enable_zoom;
    this.variants = this.product.variants;
    this.images = this.product.images;
    this.minimumPriceArea = $(".product-price-minimum");
    this.addingToCart = false;
    this.productArea = $(".product-wrap", this.$el);
    this.$productForm = $(".product-form", this.productArea);
    this.formID = parseInt(this.$productForm.attr("data-product-form"), 10);
    this.productSelect = "#product-select-" + this.formID;
    this.$priceArea = $(".product-form .product-price", this.productArea);
    this.$addToCartButton = $(".submit-wrapper input", this.productArea);
    this.$productThumbnails = $(".product-images .product-thumbnails img", this.productArea);
    $productJSON = $("[data-product-json-" + this.formID + "]", this.productArea);
    $productSettings = $("[data-product-settings-" + this.formID + "]", this.productArea);
    this.productJSON = this.product;
    this.productSettings = this.data.productSettings;
    this.$variantDropdowns = $("[data-option-select=" + this.formID + "]", this.productArea);
    this.options = this.productJSON.options;
    this.variants = this.productJSON.variants;
    if ($(".product-form").length) {
      this.setupVariants();
    }
    if (this.zoomEnabled && $(".product-images").length) {
      this.zoomView = new ImageZoomView({
        el: $(".product-main-image", this.$el)
      });
    }
    return Shopify.onError = (function(_this) {
      return function(XMLHttpRequest) {
        return _this.handleErrors(XMLHttpRequest);
      };
    })(this);
  };

  ProductView.prototype.sectionBinding = function() {
    this.$el.on('shopify:section:load', (function(_this) {
      return function(event) {
        if (!$(event.target).hasClass('section-product')) {
          return;
        }
        _this.delegateEvents();
        return _this.validate();
      };
    })(this));
    return this.$el.on('shopify:section:unload', (function(_this) {
      return function(event) {
        var ref1;
        if (!$(event.target).hasClass('section-product')) {
          return;
        }
        _this.undelegateEvents();
        return (ref1 = _this.zoomView) != null ? ref1.remove() : void 0;
      };
    })(this));
  };

  ProductView.prototype.swapImage = function(e, newImage) {
    var $image, $nextImage, imageId;
    imageId = $(e.target).data("image-id");
    $nextImage = $(this.images[imageId]);
    $nextImage.css("display", "none");
    $image = $(".product-main-image img", this.$el);
    rimg["shopify"].unwatch($image[0]);
    $nextImage.one("load", (function(_this) {
      return function() {
        $image.remove();
        $nextImage.css("display", "");
        rimg["shopify"].watch($(".product-main-image img", _this.$el)[0]);
        if (_this.zoomEnabled) {
          return $(".product-main-image").trigger("prepare-zoom");
        }
      };
    })(this));
    return $image.after($nextImage);
  };

  ProductView.prototype.setupVariants = function() {
    var dropdownSettings, variantHelperDefaults;
    variantHelperDefaults = {
      $addToCartButton: this.$addToCartButton,
      $priceFields: this.$priceArea,
      $productForm: this.$productForm,
      $productThumbnails: this.$productThumbnails,
      formID: this.formID,
      productSettings: this.productSettings,
      productJSON: this.productJSON
    };
    if (this.$variantDropdowns.length) {
      dropdownSettings = {
        $selector: this.$variantDropdowns,
        type: 'select'
      };
      dropdownSettings = window.ThemeUtils.extend(variantHelperDefaults, dropdownSettings);
      return this.variantHelpers = new VariantHelper(dropdownSettings);
    }
  };

  ProductView.prototype.updateVariantLabel = function(e, select) {
    var selectedVariant;
    select = e ? e.target : select;
    select = $(select);
    selectedVariant = select.find("option:selected").val();
    return select.prev(".select-text").html(selectedVariant);
  };

  ProductView.prototype.addToCart = function(e) {
    e.preventDefault();
    $(".error-message").remove();
    return Shopify.addItemFromForm("product-form", (function(_this) {
      return function(data) {
        var message;
        $(".cart-count").addClass("active-cart");
        message = "{{ 'products.product.success_html' | t | escape }}".replace("{% raw %}{{ product }}{% endraw %}", "" + _this.product.title).replace("{% raw %}{{ cart_link }}{% endraw %}", "<a href='/cart'>{{ 'products.product.cart_link' | t }}</a>").replace("{% raw %}{{ continue_link }}{% endraw %}", "<a href='/collections/all'>{{ 'products.product.continue_link' | t }}</a>").replace("{% raw %}{{ checkout_link }}{% endraw %}", "<a href='/checkout'>{{ 'products.product.checkout_link' | t }}</a>");
        return setTimeout(function() {
          _this.$el.find(".product-message").html(message).addClass("success-message").removeClass("error-message");
          return _this.updateCart(data);
        }, 500);
      };
    })(this));
  };

  ProductView.prototype.updateCart = function(newItem) {
    return Shopify.getCart((function(_this) {
      return function(cart) {
        var cartCount, cartCountText, ref;
        cartCount = cart.item_count;
        cartCountText = cart.item_count === 1 ? _this.cartText[0] : _this.cartText[1];
        $(".bag-count").text(cart.item_count);
        $(".bag-text").html(cartCountText);
        ref = cart.items;
      };
    })(this));
  };

  ProductView.prototype.handleErrors = function(response) {
    var error;
    error = JSON.parse(response.responseText);
    return $(".product-form").append("<div class=\"error-message\">" + error.description + "</div>");
  };

  ProductView.prototype.onSectionUnload = function() {
    var ref1;
    return (ref1 = this.zoomView) != null ? ref1.remove() : void 0;
  };

  return ProductView;

})();

window.GiftCardView = (function(superClass) {
  extend(GiftCardView, superClass);

  function GiftCardView() {
    return GiftCardView.__super__.constructor.apply(this, arguments);
  }

  GiftCardView.prototype.initialize = function() {
    return this.addQrCode();
  };

  GiftCardView.prototype.addQrCode = function() {
    var qrWrapper;
    qrWrapper = $('[data-qr-code]');
    return new QRCode(qrWrapper[0], {
      text: qrWrapper.data('qr-code'),
      width: 120,
      height: 120
    });
  };

  return GiftCardView;

})(Backbone.View);

window.ThemeEditor = (function(superClass) {
  extend(ThemeEditor, superClass);

  function ThemeEditor() {
    return ThemeEditor.__super__.constructor.apply(this, arguments);
  }

  ThemeEditor.prototype.initialize = function() {
    this.instanceHandlers = {};
    this.instances = {};
    return $(document).on('shopify:section:load', (function(_this) {
      return function(event) {
        return _this._onSectionLoad(event);
      };
    })(this)).on('shopify:section:unload', (function(_this) {
      return function(event) {
        return _this._onSectionUnload(event);
      };
    })(this)).on('shopify:section:select', (function(_this) {
      return function(event) {
        return _this._onSectionSelect(event);
      };
    })(this)).on('shopify:section:deselect', (function(_this) {
      return function(event) {
        return _this._onSectionDeselect(event);
      };
    })(this)).on('shopify:block:select', (function(_this) {
      return function(event) {
        return _this._onBlockSelect(event);
      };
    })(this)).on('shopify:block:deselect', (function(_this) {
      return function(event) {
        return _this._onBlockDeselect(event);
      };
    })(this));
  };

  ThemeEditor.prototype._findInstance = function(event) {
    var $container, instance;
    instance = this.instances[event.originalEvent.detail.sectionId];
    if (instance != null) {
      return instance;
    } else {
      $container = $('[data-section-id]', event.target);
      return this._createInstance($container);
    }
  };

  ThemeEditor.prototype._createInstance = function($container, instanceHandler) {
    var data, el, instance, sectionId, sectionType;
    el = $container.parent().get(0);
    data = this._loadData(el);
    sectionType = $container.attr('data-section-type');
    sectionId = $container.attr('data-section-id');
    if (sectionType == null) {
      return;
    }
    instanceHandler = instanceHandler || this.instanceHandlers[sectionType];
    instance = {
      instanceHandler: instanceHandler,
      el: el,
      data: data,
      $container: $container,
      sectionId: sectionId
    };
    this.instances[sectionId] = instance;
    return instance;
  };

  ThemeEditor.prototype._loadData = function(el) {
    var data, dataEl, error;
    dataEl = el.querySelector('[data-section-data]');
    if (!dataEl) {
      return {};
    }
    data = dataEl.getAttribute('data-section-data') || dataEl.innerHTML;
    try {
      return JSON.parse(data);
    } catch (error1) {
      error = error1;
      console.warn("Sections: invalid section data found. " + error.message);
      return {};
    }
  };


  /*
      Action: A section has been added or re-rendered.
      Expected: Re-execute any JavaScript needed for the section to work and
          display properly (as if the page had just been loaded).
   */

  ThemeEditor.prototype._onSectionLoad = function(event) {
    var $container, ref1, ref2;
    $container = $('[data-section-id]', event.target);
    if (!$container.length) {
      return;
    }
    return (ref1 = this._createInstance($container)) != null ? (ref2 = ref1.instanceHandler) != null ? typeof ref2.onSectionLoad === "function" ? ref2.onSectionLoad(event) : void 0 : void 0 : void 0;
  };


  /*
      Action: A section has been deleted or is being re-rendered.
      Expected: Clean up any event listeners, variables, etc., so that
          nothing breaks when the page is interacted with and no memory leaks occur.
   */

  ThemeEditor.prototype._onSectionUnload = function(event) {
    var instance, ref1;
    instance = this._findInstance(event);
    if (instance != null) {
      if ((ref1 = instance.instanceHandler) != null) {
        if (typeof ref1.onSectionUnload === "function") {
          ref1.onSectionUnload(event);
        }
      }
    }
    if (instance) {
      return delete this.instances[instance.sectionId];
    }
  };


  /*
      Action: User has selected the section in the sidebar.
      Expected: Make sure the section is in view and stays
          in view while selected (scrolling happens automatically).
      Example: Could be used to pause a slideshow
   */

  ThemeEditor.prototype._onSectionSelect = function(event) {
    var ref1, ref2;
    return (ref1 = this._findInstance(event)) != null ? (ref2 = ref1.instanceHandler) != null ? typeof ref2.onSectionSelect === "function" ? ref2.onSectionSelect(event) : void 0 : void 0 : void 0;
  };


  /*
      Action: User has deselected the section in the sidebar.
      Expected: (None)
      Example: Could be used to restart slideshows that are no longer being interacted with.
   */

  ThemeEditor.prototype._onSectionDeselect = function(event) {
    var ref1, ref2;
    return (ref1 = this._findInstance(event)) != null ? (ref2 = ref1.instanceHandler) != null ? typeof ref2.onSectionDeselect === "function" ? ref2.onSectionDeselect(event) : void 0 : void 0 : void 0;
  };


  /*
      Action: User has selected the block in the sidebar.
      Expected: Make sure the block is in view and stays
          in view while selected (scrolling happens automatically).
      Example: Can be used to to trigger a slideshow to bring a slide/block into view
   */

  ThemeEditor.prototype._onBlockSelect = function(event) {
    var ref1, ref2;
    return (ref1 = this._findInstance(event)) != null ? (ref2 = ref1.instanceHandler) != null ? typeof ref2.onBlockSelect === "function" ? ref2.onBlockSelect(event) : void 0 : void 0 : void 0;
  };


  /*
      Action: User has deselected the block in the sidebar.
      Expected: (None)
      Example: Resume a slideshow
   */

  ThemeEditor.prototype._onBlockDeselect = function(event) {
    var ref1, ref2;
    return (ref1 = this._findInstance(event)) != null ? (ref2 = ref1.instanceHandler) != null ? typeof ref2.onBlockDeselect === "function" ? ref2.onBlockDeselect(event) : void 0 : void 0 : void 0;
  };


  /*
      Auto initialisation of a section for the store front
   */

  ThemeEditor.prototype._sectionInit = function(instance) {
    var ref1;
    return instance != null ? (ref1 = instance.instanceHandler) != null ? typeof ref1.init === "function" ? ref1.init(instance) : void 0 : void 0 : void 0;
  };


  /*
      Registration of a section
          - Takes a string parameter as the first argument which
            matches to `[data-section-type]`
  
       * Example
          @sections = new Sections()
          @sections.register('some-section-type', @someSectionClass)
   */

  ThemeEditor.prototype.register = function(type, instanceHandler) {

    /*
        Storage of a instanceHandler based on the sectionType allows _onSectionLoad
           to connect a new section to it's registered instanceHandler
     */
    this.instanceHandlers[type] = instanceHandler;
    return $("[data-section-type=" + type + "]").each((function(_this) {
      return function(index, container) {
        var $container;
        $container = $(container);
        return _this._sectionInit(_this._createInstance($container, instanceHandler));
      };
    })(this));
  };


  /*
      Public method to retrieve information on an instance based on the
      bubbled `event`
   */

  ThemeEditor.prototype.getInstance = function(event) {
    return this._findInstance(event);
  };

  return ThemeEditor;

})(Backbone.View);

window.ThemeUtils = {
  extend: function() {
    var dest, j, k, len, obj, objs, v;
    dest = arguments[0], objs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    for (j = 0, len = objs.length; j < len; j++) {
      obj = objs[j];
      for (k in obj) {
        v = obj[k];
        dest[k] = v;
      }
    }
    return dest;
  },
  windowWidth: function() {
    return window.innerWidth || this.window.width();
  },
  debounce: function(func, wait, immediate) {
    var timeout;
    timeout = null;
    return function() {
      var args, callNow, context, later;
      context = this;
      args = arguments;
      later = function() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  },
  inViewport: function(el) {
    var bounds, rect;
    if (typeof jQuery === "function" && el instanceof jQuery) {
      el = el[0];
    }
    rect = el.getBoundingClientRect();
    bounds = {
      top: rect.top >= 0,
      bottom: rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
    };
    return bounds.top && bounds.bottom;
  },
  unique: function(array) {
    var j, key, output, ref1, results, value;
    output = {};
    for (key = j = 0, ref1 = array.length; 0 <= ref1 ? j < ref1 : j > ref1; key = 0 <= ref1 ? ++j : --j) {
      output[array[key]] = array[key];
    }
    results = [];
    for (key in output) {
      value = output[key];
      results.push(value);
    }
    return results;
  }
};

window.LinkedOptions = (function() {
  function LinkedOptions(options) {
    this.options = options;
    this._init();
  }

  LinkedOptions.prototype._init = function() {
    return this._mapVariants(this.options.productJSON);
  };

  LinkedOptions.prototype._getCurrent = function(optionIndex) {
    var key, option1, option2, selector;
    if (this.options.type === 'select') {
      switch (optionIndex) {
        case 0:
          key = 'root';
          selector = this.options.$selector.eq(0);
          break;
        case 1:
          key = this.options.$selector.eq(0).val();
          selector = this.options.$selector.eq(1);
          break;
        case 2:
          key = (this.options.$selector.eq(0).val()) + " / " + (this.options.$selector.eq(1).val());
          selector = this.options.$selector.eq(2);
      }
    }
    if (this.options.type === 'radio') {
      switch (optionIndex) {
        case 0:
          key = 'root';
          selector = this.options.$selector.filter('[data-option-index=0]').filter(':checked');
          break;
        case 1:
          key = this.options.$selector.filter('[data-option-index=0]').filter(':checked').val();
          selector = this.options.$selector.filter('[data-option-index=1]').filter(':checked');
          break;
        case 2:
          option1 = this.options.$selector.filter('[data-option-index=0]').filter(':checked').val();
          option2 = this.options.$selector.filter('[data-option-index=1]').filter(':checked').val();
          key = option1 + " / " + option2;
          selector = this.options.$selector.filter('[data-option-index=2]').filter(':checked');
      }
    }
    return {
      key: key,
      selector: selector
    };
  };

  LinkedOptions.prototype._updateOptions = function(optionIndex, optionsMap) {
    var $nextOption, $option, $selector, $selectorOptions, availableOptions, initialValue, j, key, l, len, len1, nextSelector, option, ref1, selector, updateSelected;
    nextSelector = optionIndex + 1;
    updateSelected = false;
    ref1 = this._getCurrent(optionIndex), key = ref1.key, selector = ref1.selector;
    availableOptions = optionsMap[key] || [];
    if (this.options.type === 'select') {
      $selector = this.options.$productForm.find(selector);
      initialValue = $selector.val();
      $selectorOptions = $selector.find('option');
      for (j = 0, len = $selectorOptions.length; j < len; j++) {
        option = $selectorOptions[j];
        $option = $(option);
        if (availableOptions.indexOf(option.value) === -1) {
          if (option.selected) {
            updateSelected = true;
          }
          $option.prop('disabled', true).prop('selected', false);
        } else {
          $option.prop('disabled', false);
        }
      }
      if (availableOptions.indexOf(initialValue) !== -1) {
        $selector.val(initialValue);
      }
      if (updateSelected) {
        $selectorOptions.filter(':not(:disabled)').eq(0).prop('selected', true);
      }
    }
    if (this.options.type === 'radio') {
      $selector = this.options.$selector.filter("[data-option-index=" + optionIndex + "]");
      for (l = 0, len1 = $selector.length; l < len1; l++) {
        option = $selector[l];
        $option = $(option);
        if (availableOptions.indexOf(option.value) === -1) {
          if (option.checked) {
            updateSelected = true;
          }
          $option.prop('disabled', true).prop('checked', false);
        } else {
          $option.prop('disabled', false);
        }
      }
      if (updateSelected) {
        $selector.filter(':not(:disabled)').eq(0).attr('checked', true).trigger('click');
      }
    }
    $selector.trigger('change');
    $nextOption = this.options.$selector.filter("[data-option-index=" + nextSelector + "]");
    if ($nextOption.length !== 0) {
      return this._updateOptions(nextSelector, optionsMap);
    }
  };

  LinkedOptions.prototype._mapVariants = function(product) {
    var j, key, len, optionsMap, ref1, variant;
    optionsMap = [];
    optionsMap['root'] = [];
    ref1 = product.variants;
    for (j = 0, len = ref1.length; j < len; j++) {
      variant = ref1[j];
      if (variant.available) {
        optionsMap['root'].push(variant.option1);
        optionsMap['root'] = window.ThemeUtils.unique(optionsMap['root']);
        if (product.options.length > 1) {
          key = variant.option1;
          optionsMap[key] = optionsMap[key] || [];
          optionsMap[key].push(variant.option2);
          optionsMap[key] = window.ThemeUtils.unique(optionsMap[key]);
        }
        if (product.options.length > 2) {
          key = variant.option1 + " / " + variant.option2;
          optionsMap[key] = optionsMap[key] || [];
          optionsMap[key].push(variant.option3);
          optionsMap[key] = window.ThemeUtils.unique(optionsMap[key]);
        }
      }
    }
    this._updateOptions(0, optionsMap);
    return this.options.$selector.on('change', (function(_this) {
      return function(event) {
        var index, nextSelector;
        index = parseInt($(event.currentTarget).attr('data-option-index'), 10);
        nextSelector = index + 1;
        return _this._updateOptions(nextSelector, optionsMap);
      };
    })(this));
  };

  return LinkedOptions;

})();

window.VariantHelper = (function() {
  function VariantHelper(options) {
    var defaultOptions, isShopify;
    defaultOptions = {
      $addToCartButton: null,
      $priceFields: null,
      $productForm: null,
      $productThumbnails: null,
      $selector: null,
      type: 'select',
      productJSON: null,
      productSettings: null
    };
    this.options = window.ThemeUtils.extend(defaultOptions, options);
    this.$body = $(document.body);
    this.linkedOptions = null;
    this.enableHistory = false;
    this.$masterSelect = this.options.$productForm.find("#product-select-" + this.options.formID);
    isShopify = window.Shopify && window.Shopify.preview_host;
    if (window.history && window.history.replaceState && this.options.productSettings.enableHistory && !isShopify) {
      this.enableHistory = true;
    }
    this._init();
    this._bindEvents();
  }

  VariantHelper.prototype._init = function() {
    var j, len, ref1, select;
    if (this.options.type === 'select') {
      ref1 = this.options.$selector;
      for (j = 0, len = ref1.length; j < len; j++) {
        select = ref1[j];
        this._setSelectLabel(null, $(select));
      }
    }
    if (this.options.productSettings.linkedOptions) {
      return this.linkedOptions = new LinkedOptions(this.options);
    }
  };

  VariantHelper.prototype._bindEvents = function() {
    return this.options.$selector.on('change', (function(_this) {
      return function(event) {
        return _this._variantChange(event);
      };
    })(this));
  };

  VariantHelper.prototype._setSelectLabel = function(event, $target) {
    var selectedOption;
    if (event == null) {
      event = null;
    }
    if ($target == null) {
      $target = false;
    }
    if (!$target) {
      $target = $(event.currentTarget);
    }
    selectedOption = $target.find('option:selected').val();
    return $target.prev('[data-select-text]').find('[data-selected-option]').text(selectedOption);
  };

  VariantHelper.prototype._getCurrentOptions = function() {
    var $inputs, productOptions;
    productOptions = [];
    $inputs = this.options.$selector;
    if (this.options.type === 'radio') {
      $inputs = $inputs.filter(':checked');
    }
    $inputs.each(function(index, element) {
      return productOptions.push($(element).val());
    });
    return productOptions;
  };

  VariantHelper.prototype._getVariantFromOptions = function(productOptions) {
    var foundVariant, isMatch, j, len, ref1, variant;
    if (this.options.productJSON.variants == null) {
      return;
    }
    foundVariant = null;
    ref1 = this.options.productJSON.variants;
    for (j = 0, len = ref1.length; j < len; j++) {
      variant = ref1[j];
      isMatch = productOptions.every(function(value, index) {
        return variant.options[index] === value;
      });
      if (isMatch) {
        foundVariant = variant;
      }
    }
    return foundVariant;
  };

  VariantHelper.prototype._updateMasterSelect = function(variant) {
    var ref1;
    if (variant == null) {
      return;
    }
    if ((ref1 = this.$masterSelect.find("[data-variant-id=" + variant.id + "]")) != null) {
      ref1.prop('selected', true);
    }
    return this.$masterSelect.trigger('change');
  };

  VariantHelper.prototype._updatePrice = function(variant) {
    var $addToCartButton, $moneyEl, $priceFields, attribute, j, l, len, len1, priceField, productSettings, ref1;
    $addToCartButton = this.options.$addToCartButton;
    $priceFields = this.options.$priceFields;
    productSettings = this.options.productSettings;
    if (variant) {
      for (j = 0, len = $priceFields.length; j < len; j++) {
        priceField = $priceFields[j];
        $moneyEl = $(priceField).children('.money');
        ref1 = $moneyEl[0].attributes;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          attribute = ref1[l];
          if (attribute.name.indexOf("data-") > -1) {
            $moneyEl.attr(attribute.name, "");
          }
        }
      }
      if (variant.available) {
        $addToCartButton.val(productSettings.addToCartText).removeClass('disabled').removeAttr('disabled');
      } else {
        $addToCartButton.val(productSettings.soldOutText).addClass('disabled').attr('disabled', 'disabled');
      }
      if (variant.compare_at_price > variant.price) {
        $priceFields.find('.money:not(.original)').html(Shopify.formatMoney(variant.price, Shop.moneyFormat)).attr("data-currency-" + Shop.currency, Shopify.formatMoney(variant.price, Shop.moneyFormat)).attr("data-currency", Shop.currency);
        $priceFields.find('.money.original').html(Shopify.formatMoney(variant.compare_at_price, Shop.moneyFormat)).removeClass('hidden').attr("data-currency-" + Shop.currency, Shopify.formatMoney(variant.compare_at_price, Shop.moneyFormat)).attr("data-currency", Shop.currency);
      } else {
        $priceFields.find('.money:not(.original)').html(Shopify.formatMoney(variant.price, Shop.moneyFormat)).attr("data-currency-" + Shop.currency, Shopify.formatMoney(variant.price, Shop.moneyFormat)).attr("data-currency", Shop.currency);
        $priceFields.find('.money.original').addClass('hidden').attr("data-currency-" + Shop.currency, Shopify.formatMoney(variant.compare_at_price, Shop.moneyFormat)).attr("data-currency", Shop.currency);
      }
    } else {
      $addToCartButton.val(productSettings.unavailableText).addClass('disabled').attr('disabled', 'disabled');
    }
    return this._updateCurrency();
  };

  VariantHelper.prototype._updateImages = function(variant) {
    var index, ref1;
    index = variant != null ? (ref1 = variant.featured_image) != null ? ref1.position : void 0 : void 0;
    if (index == null) {
      return;
    }
    return this.options.$productThumbnails.eq(index - 1).trigger('click');
  };

  VariantHelper.prototype._updateHistory = function(variant) {
    var newUrl, variantUrl;
    if (!(this.enableHistory && (variant != null))) {
      return;
    }
    newUrl = [window.location.protocol, '//', window.location.host, window.location.pathname, '?variant=', variant.id];
    variantUrl = newUrl.join('');
    return window.history.replaceState({
      path: variantUrl
    }, '', variantUrl);
  };

  VariantHelper.prototype._variantChange = function(event) {
    var productOptions, variant;
    if (this.options.type === 'select') {
      this._setSelectLabel(event);
    }
    productOptions = this._getCurrentOptions();
    variant = this._getVariantFromOptions(productOptions);
    this._updateMasterSelect(variant);
    this._updatePrice(variant);
    this._updateImages(variant);
    return this._updateHistory(variant);
  };

  VariantHelper.prototype._updateCurrency = function() {
    if (Shop.currencySwitcher) {
      return $('.currency-switcher').trigger('switch-currency');
    }
  };

  return VariantHelper;

})();



/*!
 * pxs-map v2.0.0
 * (c) 2018 undefined
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('jquery')) :
	typeof define === 'function' && define.amd ? define(['jquery'], factory) :
	(global.PxsMap = factory(global.$));
}(this, (function ($) { 'use strict';

$ = $ && $.hasOwnProperty('default') ? $['default'] : $;

var justDebounce = debounce;

function debounce(fn, delay, at_start, guarantee) {
  var timeout;
  var args;
  var self;

  return function debounced() {
    self = this;
    args = Array.prototype.slice.call(arguments);

    if (timeout && (at_start || guarantee)) {
      return;
    } else if (!at_start) {
      clear();

      timeout = setTimeout(run, delay);
      return timeout;
    }

    timeout = setTimeout(clear, delay);
    fn.apply(self, args);

    function run() {
      clear();
      fn.apply(self, args);
    }

    function clear() {
      clearTimeout(timeout);
      timeout = null;
    }
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var PxsMap = function () {
  function PxsMap(section) {
    var _this = this;

    classCallCheck(this, PxsMap);

    this.$el = $('[data-map]', section.el);
    this.settings = section.data;
    this.map = null;
    this.center = null;

    this.$container = $('[data-map-container]', this.$el);

    // Scale so range is 12 ~ 17, rather than 1 to 6
    this.zoom = 11 + parseInt(this.settings.zoom, 10);
    if (isNaN(this.zoom)) this.zoom = 13;

    this.colors = null;

    if (this.settings.colors) {
      this.colors = this.settings.colors;
    }

    this.resize = this.resize.bind(this);

    this.address = this.settings.address;
    this.apiKey = this.settings.api_key;

    if (this.apiKey) {
      if (window.googleMaps === undefined) {
        window.googleMaps = true;

        $.getScript('https://maps.googleapis.com/maps/api/js?key=' + this.apiKey).done(function () {
          _this._createMap();
        }).fail(function (status) {
          console.error(status);
        });
      } else {
        this._createMap();
      }
    }
  }

  createClass(PxsMap, [{
    key: '_createMap',
    value: function _createMap() {
      var _this2 = this;

      return this.geolocate().done(function (results) {
        _this2.map = new google.maps.Map(_this2.$container.get(0), {
          center: results[0].geometry.location,
          clickableIcons: false,
          disableDefaultUI: true,
          disableDoubleClickZoom: true,
          gestureHandling: 'none',
          keyboardShortcuts: false,
          maxZoom: _this2.zoom,
          minZoom: _this2.zoom,
          scrollWheel: false,
          styles: _this2._getMapStyles(),
          zoom: _this2.zoom,
          zoomControl: false
        });
        _this2.center = _this2.map.getCenter();
        _this2.map.panBy(0, 0);

        new google.maps.Marker({
          clickable: false,
          map: _this2.map,
          position: _this2.center
        });

        google.maps.event.addDomListener(window, 'resize', justDebounce(_this2.resize, 250, true, true));
      }).fail(function (status) {
        var usageLimits = 'https://developers.google.com/maps/faq#usagelimits';
        var errorMessage = void 0;

        switch (status) {
          case 'ZERO_RESULTS':
            errorMessage = '<p>Unable to find the address:</p> ' + _this2.address;
            break;
          case 'OVER_QUERY_LIMIT':
            errorMessage = '\n              <p>Unable to load Google Maps, you have reached your usage limit.</p>\n              <p>\n                Please visit\n                <a href="' + usageLimits + '" target="_blank">' + usageLimits + '</a>\n                for more details.\n              </p>\n            ';
            break;
          default:
            errorMessage = 'Unable to load Google Maps.';
            break;
        }

        _this2.displayErrorInThemeEditor(errorMessage, status);
      });
    }
  }, {
    key: 'geolocate',
    value: function geolocate() {
      var deferred = $.Deferred();
      var geocoder = new google.maps.Geocoder();

      geocoder.geocode({ address: this.address }, function (results, status) {
        if (status !== google.maps.GeocoderStatus.OK) {
          deferred.reject(status);
        }

        deferred.resolve(results);
      });

      return deferred;
    }
  }, {
    key: 'resize',
    value: function resize() {
      if (this.map) {
        google.maps.event.trigger(this.map, 'resize');
        this.map.setCenter(this.center);
        this.map.panBy(0, 100);
      }
    }
  }, {
    key: 'onSectionUnload',
    value: function onSectionUnload() {
      if (this.map) {
        google.maps.event.clearListeners(this.map, 'resize');
      }
    }
  }, {
    key: '_getMapStyles',
    value: function _getMapStyles() {
      if (!this.colors) {
        return;
      }

      return [{ elementType: 'geometry', stylers: [{ color: this.colors.e }] }, { elementType: 'labels.icon', stylers: [{ visibility: 'off' }] }, { elementType: 'labels.text.fill', stylers: [{ color: this.colors.a }] }, { elementType: 'labels.text.stroke', stylers: [{ color: this.colors.e }] }, { featureType: 'administrative', elementType: 'geometry', stylers: [{ visibility: 'off' }] }, { featureType: 'administrative.country', stylers: [{ visibility: 'off' }] }, { featureType: 'administrative.land_parcel', stylers: [{ visibility: 'off' }] }, { featureType: 'administrative.neighborhood', stylers: [{ visibility: 'off' }] }, { featureType: 'administrative.locality', stylers: [{ visibility: 'off' }] }, { featureType: 'poi', stylers: [{ visibility: 'off' }] }, { featureType: 'road', elementType: 'geometry.fill', stylers: [{ color: this.colors.d }] }, { featureType: 'road', elementType: 'labels.icon', stylers: [{ visibility: 'off' }] }, { featureType: 'road.arterial', elementType: 'geometry', stylers: [{ color: this.colors.c }] }, { featureType: 'road.highway', elementType: 'geometry', stylers: [{ color: this.colors.b }] }, { featureType: 'road.highway.controlled_access', stylers: [{ visibility: 'off' }] }, { featureType: 'road.local', elementType: 'labels.text.fill', stylers: [{ color: this.colors.b }] }, { featureType: 'road.local', elementType: 'labels.text.stroke', stylers: [{ color: this.colors.e }] }, { featureType: 'transit', stylers: [{ visibility: 'off' }] }, { featureType: 'water', elementType: 'geometry', stylers: [{ color: this.colors.f }] }];
    }
  }, {
    key: 'displayErrorInThemeEditor',
    value: function displayErrorInThemeEditor(errorMessage) {
      var isThemeEditor = window.Shopify && window.Shopify.designMode;

      if (!isThemeEditor) {
        return;
      }

      this.$container.html('<div class="map-error-message">' + errorMessage + '</div>');
    }
  }]);
  return PxsMap;
}();

return PxsMap;

})));

;


    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
     *
     *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     *
     */
    
    (function(window, document) {
    'use strict';
    
    
    // Exits early if all IntersectionObserver and IntersectionObserverEntry
    // features are natively supported.
    if ('IntersectionObserver' in window &&
        'IntersectionObserverEntry' in window &&
        'intersectionRatio' in window.IntersectionObserverEntry.prototype) {
    
      // Minimal polyfill for Edge 15's lack of `isIntersecting`
      // See: https://github.com/w3c/IntersectionObserver/issues/211
      if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
        Object.defineProperty(window.IntersectionObserverEntry.prototype,
          'isIntersecting', {
          get: function () {
            return this.intersectionRatio > 0;
          }
        });
      }
      return;
    }
    
    
    /**
     * An IntersectionObserver registry. This registry exists to hold a strong
     * reference to IntersectionObserver instances currently observering a target
     * element. Without this registry, instances without another reference may be
     * garbage collected.
     */
    var registry = [];
    
    
    /**
     * Creates the global IntersectionObserverEntry constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
     * @param {Object} entry A dictionary of instance properties.
     * @constructor
     */
    function IntersectionObserverEntry(entry) {
      this.time = entry.time;
      this.target = entry.target;
      this.rootBounds = entry.rootBounds;
      this.boundingClientRect = entry.boundingClientRect;
      this.intersectionRect = entry.intersectionRect || getEmptyRect();
      this.isIntersecting = !!entry.intersectionRect;
    
      // Calculates the intersection ratio.
      var targetRect = this.boundingClientRect;
      var targetArea = targetRect.width * targetRect.height;
      var intersectionRect = this.intersectionRect;
      var intersectionArea = intersectionRect.width * intersectionRect.height;
    
      // Sets intersection ratio.
      if (targetArea) {
        this.intersectionRatio = intersectionArea / targetArea;
      } else {
        // If area is zero and is intersecting, sets to 1, otherwise to 0
        this.intersectionRatio = this.isIntersecting ? 1 : 0;
      }
    }
    
    
    /**
     * Creates the global IntersectionObserver constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
     * @param {Function} callback The function to be invoked after intersection
     *     changes have queued. The function is not invoked if the queue has
     *     been emptied by calling the `takeRecords` method.
     * @param {Object=} opt_options Optional configuration options.
     * @constructor
     */
    function IntersectionObserver(callback, opt_options) {
    
      var options = opt_options || {};
    
      if (typeof callback != 'function') {
        throw new Error('callback must be a function');
      }
    
      if (options.root && options.root.nodeType != 1) {
        throw new Error('root must be an Element');
      }
    
      // Binds and throttles `this._checkForIntersections`.
      this._checkForIntersections = throttle(
          this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);
    
      // Private properties.
      this._callback = callback;
      this._observationTargets = [];
      this._queuedEntries = [];
      this._rootMarginValues = this._parseRootMargin(options.rootMargin);
    
      // Public properties.
      this.thresholds = this._initThresholds(options.threshold);
      this.root = options.root || null;
      this.rootMargin = this._rootMarginValues.map(function(margin) {
        return margin.value + margin.unit;
      }).join(' ');
    }
    
    
    /**
     * The minimum interval within which the document will be checked for
     * intersection changes.
     */
    IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;
    
    
    /**
     * The frequency in which the polyfill polls for intersection changes.
     * this can be updated on a per instance basis and must be set prior to
     * calling `observe` on the first target.
     */
    IntersectionObserver.prototype.POLL_INTERVAL = null;
    
    /**
     * Use a mutation observer on the root element
     * to detect intersection changes.
     */
    IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;
    
    
    /**
     * Starts observing a target element for intersection changes based on
     * the thresholds values.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.observe = function(target) {
      var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
        return item.element == target;
      });
    
      if (isTargetAlreadyObserved) {
        return;
      }
    
      if (!(target && target.nodeType == 1)) {
        throw new Error('target must be an Element');
      }
    
      this._registerInstance();
      this._observationTargets.push({element: target, entry: null});
      this._monitorIntersections();
      this._checkForIntersections();
    };
    
    
    /**
     * Stops observing a target element for intersection changes.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.unobserve = function(target) {
      this._observationTargets =
          this._observationTargets.filter(function(item) {
    
        return item.element != target;
      });
      if (!this._observationTargets.length) {
        this._unmonitorIntersections();
        this._unregisterInstance();
      }
    };
    
    
    /**
     * Stops observing all target elements for intersection changes.
     */
    IntersectionObserver.prototype.disconnect = function() {
      this._observationTargets = [];
      this._unmonitorIntersections();
      this._unregisterInstance();
    };
    
    
    /**
     * Returns any queue entries that have not yet been reported to the
     * callback and clears the queue. This can be used in conjunction with the
     * callback to obtain the absolute most up-to-date intersection information.
     * @return {Array} The currently queued entries.
     */
    IntersectionObserver.prototype.takeRecords = function() {
      var records = this._queuedEntries.slice();
      this._queuedEntries = [];
      return records;
    };
    
    
    /**
     * Accepts the threshold value from the user configuration object and
     * returns a sorted array of unique threshold values. If a value is not
     * between 0 and 1 and error is thrown.
     * @private
     * @param {Array|number=} opt_threshold An optional threshold value or
     *     a list of threshold values, defaulting to [0].
     * @return {Array} A sorted list of unique and valid threshold values.
     */
    IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
      var threshold = opt_threshold || [0];
      if (!Array.isArray(threshold)) threshold = [threshold];
    
      return threshold.sort().filter(function(t, i, a) {
        if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
          throw new Error('threshold must be a number between 0 and 1 inclusively');
        }
        return t !== a[i - 1];
      });
    };
    
    
    /**
     * Accepts the rootMargin value from the user configuration object
     * and returns an array of the four margin values as an object containing
     * the value and unit properties. If any of the values are not properly
     * formatted or use a unit other than px or %, and error is thrown.
     * @private
     * @param {string=} opt_rootMargin An optional rootMargin value,
     *     defaulting to '0px'.
     * @return {Array<Object>} An array of margin objects with the keys
     *     value and unit.
     */
    IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
      var marginString = opt_rootMargin || '0px';
      var margins = marginString.split(/\s+/).map(function(margin) {
        var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
        if (!parts) {
          throw new Error('rootMargin must be specified in pixels or percent');
        }
        return {value: parseFloat(parts[1]), unit: parts[2]};
      });
    
      // Handles shorthand.
      margins[1] = margins[1] || margins[0];
      margins[2] = margins[2] || margins[0];
      margins[3] = margins[3] || margins[1];
    
      return margins;
    };
    
    
    /**
     * Starts polling for intersection changes if the polling is not already
     * happening, and if the page's visibilty state is visible.
     * @private
     */
    IntersectionObserver.prototype._monitorIntersections = function() {
      if (!this._monitoringIntersections) {
        this._monitoringIntersections = true;
    
        // If a poll interval is set, use polling instead of listening to
        // resize and scroll events or DOM mutations.
        if (this.POLL_INTERVAL) {
          this._monitoringInterval = setInterval(
              this._checkForIntersections, this.POLL_INTERVAL);
        }
        else {
          addEvent(window, 'resize', this._checkForIntersections, true);
          addEvent(document, 'scroll', this._checkForIntersections, true);
    
          if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {
            this._domObserver = new MutationObserver(this._checkForIntersections);
            this._domObserver.observe(document, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
          }
        }
      }
    };
    
    
    /**
     * Stops polling for intersection changes.
     * @private
     */
    IntersectionObserver.prototype._unmonitorIntersections = function() {
      if (this._monitoringIntersections) {
        this._monitoringIntersections = false;
    
        clearInterval(this._monitoringInterval);
        this._monitoringInterval = null;
    
        removeEvent(window, 'resize', this._checkForIntersections, true);
        removeEvent(document, 'scroll', this._checkForIntersections, true);
    
        if (this._domObserver) {
          this._domObserver.disconnect();
          this._domObserver = null;
        }
      }
    };
    
    
    /**
     * Scans each observation target for intersection changes and adds them
     * to the internal entries queue. If new entries are found, it
     * schedules the callback to be invoked.
     * @private
     */
    IntersectionObserver.prototype._checkForIntersections = function() {
      var rootIsInDom = this._rootIsInDom();
      var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();
    
      this._observationTargets.forEach(function(item) {
        var target = item.element;
        var targetRect = getBoundingClientRect(target);
        var rootContainsTarget = this._rootContainsTarget(target);
        var oldEntry = item.entry;
        var intersectionRect = rootIsInDom && rootContainsTarget &&
            this._computeTargetAndRootIntersection(target, rootRect);
    
        var newEntry = item.entry = new IntersectionObserverEntry({
          time: now(),
          target: target,
          boundingClientRect: targetRect,
          rootBounds: rootRect,
          intersectionRect: intersectionRect
        });
    
        if (!oldEntry) {
          this._queuedEntries.push(newEntry);
        } else if (rootIsInDom && rootContainsTarget) {
          // If the new entry intersection ratio has crossed any of the
          // thresholds, add a new entry.
          if (this._hasCrossedThreshold(oldEntry, newEntry)) {
            this._queuedEntries.push(newEntry);
          }
        } else {
          // If the root is not in the DOM or target is not contained within
          // root but the previous entry for this target had an intersection,
          // add a new record indicating removal.
          if (oldEntry && oldEntry.isIntersecting) {
            this._queuedEntries.push(newEntry);
          }
        }
      }, this);
    
      if (this._queuedEntries.length) {
        this._callback(this.takeRecords(), this);
      }
    };
    
    
    /**
     * Accepts a target and root rect computes the intersection between then
     * following the algorithm in the spec.
     * TODO(philipwalton): at this time clip-path is not considered.
     * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
     * @param {Element} target The target DOM element
     * @param {Object} rootRect The bounding rect of the root after being
     *     expanded by the rootMargin value.
     * @return {?Object} The final intersection rect object or undefined if no
     *     intersection is found.
     * @private
     */
    IntersectionObserver.prototype._computeTargetAndRootIntersection =
        function(target, rootRect) {
    
      // If the element isn't displayed, an intersection can't happen.
      if (window.getComputedStyle(target).display == 'none') return;
    
      var targetRect = getBoundingClientRect(target);
      var intersectionRect = targetRect;
      var parent = getParentNode(target);
      var atRoot = false;
    
      while (!atRoot) {
        var parentRect = null;
        var parentComputedStyle = parent.nodeType == 1 ?
            window.getComputedStyle(parent) : {};
    
        // If the parent isn't displayed, an intersection can't happen.
        if (parentComputedStyle.display == 'none') return;
    
        if (parent == this.root || parent == document) {
          atRoot = true;
          parentRect = rootRect;
        } else {
          // If the element has a non-visible overflow, and it's not the <body>
          // or <html> element, update the intersection rect.
          // Note: <body> and <html> cannot be clipped to a rect that's not also
          // the document rect, so no need to compute a new intersection.
          if (parent != document.body &&
              parent != document.documentElement &&
              parentComputedStyle.overflow != 'visible') {
            parentRect = getBoundingClientRect(parent);
          }
        }
    
        // If either of the above conditionals set a new parentRect,
        // calculate new intersection data.
        if (parentRect) {
          intersectionRect = computeRectIntersection(parentRect, intersectionRect);
    
          if (!intersectionRect) break;
        }
        parent = getParentNode(parent);
      }
      return intersectionRect;
    };
    
    
    /**
     * Returns the root rect after being expanded by the rootMargin value.
     * @return {Object} The expanded root rect.
     * @private
     */
    IntersectionObserver.prototype._getRootRect = function() {
      var rootRect;
      if (this.root) {
        rootRect = getBoundingClientRect(this.root);
      } else {
        // Use <html>/<body> instead of window since scroll bars affect size.
        var html = document.documentElement;
        var body = document.body;
        rootRect = {
          top: 0,
          left: 0,
          right: html.clientWidth || body.clientWidth,
          width: html.clientWidth || body.clientWidth,
          bottom: html.clientHeight || body.clientHeight,
          height: html.clientHeight || body.clientHeight
        };
      }
      return this._expandRectByRootMargin(rootRect);
    };
    
    
    /**
     * Accepts a rect and expands it by the rootMargin value.
     * @param {Object} rect The rect object to expand.
     * @return {Object} The expanded rect.
     * @private
     */
    IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
      var margins = this._rootMarginValues.map(function(margin, i) {
        return margin.unit == 'px' ? margin.value :
            margin.value * (i % 2 ? rect.width : rect.height) / 100;
      });
      var newRect = {
        top: rect.top - margins[0],
        right: rect.right + margins[1],
        bottom: rect.bottom + margins[2],
        left: rect.left - margins[3]
      };
      newRect.width = newRect.right - newRect.left;
      newRect.height = newRect.bottom - newRect.top;
    
      return newRect;
    };
    
    
    /**
     * Accepts an old and new entry and returns true if at least one of the
     * threshold values has been crossed.
     * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
     *    particular target element or null if no previous entry exists.
     * @param {IntersectionObserverEntry} newEntry The current entry for a
     *    particular target element.
     * @return {boolean} Returns true if a any threshold has been crossed.
     * @private
     */
    IntersectionObserver.prototype._hasCrossedThreshold =
        function(oldEntry, newEntry) {
    
      // To make comparing easier, an entry that has a ratio of 0
      // but does not actually intersect is given a value of -1
      var oldRatio = oldEntry && oldEntry.isIntersecting ?
          oldEntry.intersectionRatio || 0 : -1;
      var newRatio = newEntry.isIntersecting ?
          newEntry.intersectionRatio || 0 : -1;
    
      // Ignore unchanged ratios
      if (oldRatio === newRatio) return;
    
      for (var i = 0; i < this.thresholds.length; i++) {
        var threshold = this.thresholds[i];
    
        // Return true if an entry matches a threshold or if the new ratio
        // and the old ratio are on the opposite sides of a threshold.
        if (threshold == oldRatio || threshold == newRatio ||
            threshold < oldRatio !== threshold < newRatio) {
          return true;
        }
      }
    };
    
    
    /**
     * Returns whether or not the root element is an element and is in the DOM.
     * @return {boolean} True if the root element is an element and is in the DOM.
     * @private
     */
    IntersectionObserver.prototype._rootIsInDom = function() {
      return !this.root || containsDeep(document, this.root);
    };
    
    
    /**
     * Returns whether or not the target element is a child of root.
     * @param {Element} target The target element to check.
     * @return {boolean} True if the target element is a child of root.
     * @private
     */
    IntersectionObserver.prototype._rootContainsTarget = function(target) {
      return containsDeep(this.root || document, target);
    };
    
    
    /**
     * Adds the instance to the global IntersectionObserver registry if it isn't
     * already present.
     * @private
     */
    IntersectionObserver.prototype._registerInstance = function() {
      if (registry.indexOf(this) < 0) {
        registry.push(this);
      }
    };
    
    
    /**
     * Removes the instance from the global IntersectionObserver registry.
     * @private
     */
    IntersectionObserver.prototype._unregisterInstance = function() {
      var index = registry.indexOf(this);
      if (index != -1) registry.splice(index, 1);
    };
    
    
    /**
     * Returns the result of the performance.now() method or null in browsers
     * that don't support the API.
     * @return {number} The elapsed time since the page was requested.
     */
    function now() {
      return window.performance && performance.now && performance.now();
    }
    
    
    /**
     * Throttles a function and delays its executiong, so it's only called at most
     * once within a given time period.
     * @param {Function} fn The function to throttle.
     * @param {number} timeout The amount of time that must pass before the
     *     function can be called again.
     * @return {Function} The throttled function.
     */
    function throttle(fn, timeout) {
      var timer = null;
      return function () {
        if (!timer) {
          timer = setTimeout(function() {
            fn();
            timer = null;
          }, timeout);
        }
      };
    }
    
    
    /**
     * Adds an event handler to a DOM node ensuring cross-browser compatibility.
     * @param {Node} node The DOM node to add the event handler to.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to add.
     * @param {boolean} opt_useCapture Optionally adds the even to the capture
     *     phase. Note: this only works in modern browsers.
     */
    function addEvent(node, event, fn, opt_useCapture) {
      if (typeof node.addEventListener == 'function') {
        node.addEventListener(event, fn, opt_useCapture || false);
      }
      else if (typeof node.attachEvent == 'function') {
        node.attachEvent('on' + event, fn);
      }
    }
    
    
    /**
     * Removes a previously added event handler from a DOM node.
     * @param {Node} node The DOM node to remove the event handler from.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to remove.
     * @param {boolean} opt_useCapture If the event handler was added with this
     *     flag set to true, it should be set to true here in order to remove it.
     */
    function removeEvent(node, event, fn, opt_useCapture) {
      if (typeof node.removeEventListener == 'function') {
        node.removeEventListener(event, fn, opt_useCapture || false);
      }
      else if (typeof node.detatchEvent == 'function') {
        node.detatchEvent('on' + event, fn);
      }
    }
    
    
    /**
     * Returns the intersection between two rect objects.
     * @param {Object} rect1 The first rect.
     * @param {Object} rect2 The second rect.
     * @return {?Object} The intersection rect or undefined if no intersection
     *     is found.
     */
    function computeRectIntersection(rect1, rect2) {
      var top = Math.max(rect1.top, rect2.top);
      var bottom = Math.min(rect1.bottom, rect2.bottom);
      var left = Math.max(rect1.left, rect2.left);
      var right = Math.min(rect1.right, rect2.right);
      var width = right - left;
      var height = bottom - top;
    
      return (width >= 0 && height >= 0) && {
        top: top,
        bottom: bottom,
        left: left,
        right: right,
        width: width,
        height: height
      };
    }
    
    
    /**
     * Shims the native getBoundingClientRect for compatibility with older IE.
     * @param {Element} el The element whose bounding rect to get.
     * @return {Object} The (possibly shimmed) rect of the element.
     */
    function getBoundingClientRect(el) {
      var rect;
    
      try {
        rect = el.getBoundingClientRect();
      } catch (err) {
        // Ignore Windows 7 IE11 "Unspecified error"
        // https://github.com/w3c/IntersectionObserver/pull/205
      }
    
      if (!rect) return getEmptyRect();
    
      // Older IE
      if (!(rect.width && rect.height)) {
        rect = {
          top: rect.top,
          right: rect.right,
          bottom: rect.bottom,
          left: rect.left,
          width: rect.right - rect.left,
          height: rect.bottom - rect.top
        };
      }
      return rect;
    }
    
    
    /**
     * Returns an empty rect object. An empty rect is returned when an element
     * is not in the DOM.
     * @return {Object} The empty rect.
     */
    function getEmptyRect() {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        width: 0,
        height: 0
      };
    }
    
    /**
     * Checks to see if a parent element contains a child elemnt (including inside
     * shadow DOM).
     * @param {Node} parent The parent element.
     * @param {Node} child The child element.
     * @return {boolean} True if the parent node contains the child node.
     */
    function containsDeep(parent, child) {
      var node = child;
      while (node) {
        if (node == parent) return true;
    
        node = getParentNode(node);
      }
      return false;
    }
    
    
    /**
     * Gets the parent node of an element or its host element if the parent node
     * is a shadow root.
     * @param {Node} node The node whose parent to get.
     * @return {Node|null} The parent node or null if no parent exists.
     */
    function getParentNode(node) {
      var parent = node.parentNode;
    
      if (parent && parent.nodeType == 11 && parent.host) {
        // If the parent is a shadow root, return the host element.
        return parent.host;
      }
      return parent;
    }
    
    
    // Exposes the constructors globally.
    window.IntersectionObserver = IntersectionObserver;
    window.IntersectionObserverEntry = IntersectionObserverEntry;
    
    }(window, document));
    
;


    /*!
     * rimg v2.1.0
     * (c) 2018 Pixel Union
     */
    (function (global, factory) {
    	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    	typeof define === 'function' && define.amd ? define(factory) :
    	(global.rimg = factory());
    }(this, (function () { 'use strict';
    
    /**
     * The default template render function. Turns a template string into an image
     * URL.
     *
     * @param {String} template
     * @param {Size} size
     * @returns {String}
     */
    function defaultTemplateRender(template, size) {
      return template.replace('{size}', size.width + 'x' + size.height);
    }
    
    /**
     * @type Settings
     */
    var defaults = {
      scale: 1,
      template: false,
      templateRender: defaultTemplateRender,
      max: { width: Infinity, height: Infinity },
      round: 32,
      placeholder: false
    };
    
    /**
     * Get a data attribute value from an element, with a default fallback and
     * sanitization step.
     *
     * @param {Element} el
     *
     * @param {String} name
     *        The data attribute name.
     *
     * @param {Object} options
     *        An object holding fallback values if the data attribute does not
     *        exist. If this object doesn't have the property, we further fallback
     *        to our defaults.
     *
     * @param {Function} [sanitize]
     *        A function to sanitize the data attribute value with.
     *
     * @returns {String|*}
     */
    function getData(el, name, options, sanitize) {
      var attr = 'data-rimg-' + name;
      if (!el.hasAttribute(attr)) return options[name] || defaults[name];
    
      var value = el.getAttribute(attr);
    
      return sanitize ? sanitize(value) : value;
    }
    
    /**
     * Sanitize data attributes that represent a size (in the form of `10x10`).
     *
     * @param {String} value
     * @returns {Object} An object with `width` and `height` properties.
     */
    function parseSize(value) {
      value = value.split('x');
      return { width: parseInt(value[0], 10), height: parseInt(value[1], 10) };
    }
    
    /**
     * Loads information about an element.
     *
     * Options can be set on the element itself using data attributes, or through
     * the `options` parameter. Data attributes take priority.
     *
     * @param {HTMLElement} el
     * @param {Settings} options
     * @returns {Item}
     */
    function parseItem(el) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    
      var isImage = el.hasAttribute('data-rimg-template');
    
      /**
       * @typedef {Settings} Item
       */
      return {
        el: el,
    
        // Type of element
        isImage: isImage,
        isBackgroundImage: isImage && el.tagName !== 'IMG',
    
        // Image scale
        scale: getData(el, 'scale', options),
    
        // Device density
        density: window.devicePixelRatio || 1,
    
        // Image template URL
        template: getData(el, 'template', options),
        templateRender: options.templateRender || defaults.templateRender,
    
        // Maximum image dimensions
        max: getData(el, 'max', options, parseSize),
    
        // Round image dimensions to the nearest multiple
        round: getData(el, 'round', options),
    
        // Placeholder image dimensions
        placeholder: getData(el, 'placeholder', options, parseSize)
      };
    }
    
    /**
     * Round to the nearest multiple.
     *
     * This is so we don't tax the image server too much.
     *
     * @param {Number} size The size, in pixels.
     * @param {Number} multiple The multiple to round to the nearest.
     * @returns {Number}
     */
    function roundSize(size, multiple) {
      return Math.ceil(size / multiple) * multiple;
    }
    
    /**
     * Get the size of an element.
     *
     * If it is too small, it's parent element is checked, and so on. This helps
     * avoid the situation where an element doesn't have a size yet or is positioned
     * out of the layout.
     *
     * @param {HTMLElement} el
     * @return {Object} size
     * @return {Number} size.width The width, in pixels.
     * @return {Number} size.height The height, in pixels.
     */
    function getElementSize(el) {
      var size = { width: 0, height: 0 };
    
      while (el) {
        size.width = el.offsetWidth;
        size.height = el.offsetHeight;
        if (size.width > 20 && size.height > 20) break;
        el = el.parentNode;
      }
    
      return size;
    }
    
    /**
     * Trigger a custom event.
     *
     * Note: this approach is deprecated, but still required to support older
     * browsers such as IE 10.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events
     *
     * @param {HTMLElement} el
     *        The element to trigger the event on.
     *
     * @param {String} name
     *        The event name.
     *
     * @returns {Boolean}
     *          True if the event was canceled.
     */
    function trigger(el, name) {
      var event = document.createEvent('Event');
      event.initEvent(name, true, true);
      return !el.dispatchEvent(event);
    }
    
    /**
     * Return the maximum supported density of the image, given the container.
     *
     * @param {Item} item
     * @param {Size} size
     */
    function supportedDensity(item, size) {
      return Math.min(Math.min(Math.max(item.max.width / size.width, 1), item.density), Math.min(Math.max(item.max.height / size.height, 1), item.density)).toFixed(2);
    }
    
    /**
     * Set the image URL on the element. Supports background images and `srcset`.
     *
     * @param {Item} item
     * @param {Size} size
     * @param {Boolean} isPlaceholder
     */
    function setImage(item, size, isPlaceholder, onLoad) {
      var render = item.templateRender;
      var density = isPlaceholder ? 1 : supportedDensity(item, size);
      var round = isPlaceholder ? 1 : item.round;
    
      var width = roundSize(size.width * density, round);
      var height = roundSize(size.height * density, round);
      var displaySize = width > item.max.width || height > item.max.height ? { width: item.max.width, height: item.max.height } : { width: width, height: height };
    
      var url = render(item.template, displaySize);
    
      // On load callback
      var image = new Image();
      image.onload = onLoad;
      image.src = url;
    
      // Set image
      if (item.isBackgroundImage) {
        item.el.style.backgroundImage = 'url(\'' + url + '\')';
      } else {
        item.el.setAttribute('srcset', url + ' ' + density + 'x');
      }
    }
    
    /**
     * Load the image, set loaded status, and trigger the load event.
     *
     * @fires rimg:load
     * @fires rimg:error
     * @param {Item} item
     * @param {Size} size
     */
    function loadFullImage(item, size) {
      var el = item.el;
    
      setImage(item, size, false, function (event) {
        if (event.type === 'load') {
          el.setAttribute('data-rimg', 'loaded');
        } else {
          el.setAttribute('data-rimg', 'error');
          trigger(el, 'rimg:error');
        }
    
        trigger(el, 'rimg:load');
      });
    }
    
    /**
     * Load in a responsive image.
     *
     * Sets the image's `srcset` attribute to the final image URLs, calculated based
     * on the actual size the image is being shown at.
     *
     * @fires rimg:loading
     *        The image URLs have been set and we are waiting for them to load.
     *
     * @fires rimg:loaded
     *        The final image has loaded.
     *
     * @fires rimg:error
     *        The final image failed loading.
     *
     * @param {Item} item
     */
    function loadImage(item) {
      var el = item.el;
    
      // Already loaded?
      var status = el.getAttribute('data-rimg');
      if (status === 'loading' || status === 'loaded') return;
    
      // Is the SVG loaded?
      if (!el.complete && !item.isBackgroundImage) {
        // Wait for the load event, then call load image
        el.addEventListener('load', function cb() {
          el.removeEventListener('load', cb);
          loadImage(item);
        });
    
        return;
      }
    
      // Trigger loading event, and stop if cancelled
      if (trigger(el, 'rimg:loading')) return;
    
      // Mark as loading
      el.setAttribute('data-rimg', 'loading');
    
      // Get element size. This is used as the ideal display size.
      var size = getElementSize(item.el);
    
      size.width *= item.scale;
      size.height *= item.scale;
    
      if (item.placeholder) {
        // Load a placeholder image first, followed by the full image. Force the
        // element to keep its dimensions while it loads. If the image is smaller
        // than the element size, use the image's size. Density is taken into account
        // for HiDPI devices to avoid blurry images.
        if (!item.isBackgroundImage) {
          el.setAttribute('width', Math.min(Math.floor(item.max.width / item.density), size.width));
          el.setAttribute('height', Math.min(Math.floor(item.max.height / item.density), size.height));
        }
    
        setImage(item, item.placeholder, true, function () {
          return loadFullImage(item, size);
        });
      } else {
        loadFullImage(item, size);
      }
    }
    
    /**
     * Prepare an element to be displayed on the screen.
     *
     * Images have special logic applied to them to swap out the different sources.
     *
     * @fires rimg:enter
     *        The element is entering the viewport.
     *
     * @param {HTMLElement} el
     * @param {Settings} options
     */
    function load(el, options) {
      if (!el) return;
      trigger(el, 'rimg:enter');
    
      var item = parseItem(el, options);
      if (item.isImage) {
        if (!item.isBackgroundImage) {
          el.setAttribute('data-rimg-template-svg', el.getAttribute('srcset'));
        }
    
        loadImage(item);
      }
    }
    
    /**
     * Prepare an element to be displayed on the screen.
     *
     * Images have special logic applied to them to swap out the different sources.
     *
     * @fires rimg:enter
     *        The element is entering the viewport.
     *
     * @param {HTMLElement} el
     * @param {Settings} options
     */
    function update(el, options) {
      if (!el) return;
      trigger(el, 'rimg:update');
    
      var item = parseItem(el, options);
    
      if (item.isImage) {
        if (!item.isBackgroundImage) {
          el.setAttribute('data-rimg', 'lazy');
          el.setAttribute('srcset', el.getAttribute('data-rimg-template-svg'));
        }
    
        loadImage(item);
      }
    }
    
    /**
     * @typedef {Object} Size
     * @property {Number} width
     * @property {Number} height
     */
    
    /**
     * A function to turn a template string into a URL.
     *
     * @callback TemplateRenderer
     * @param {String} template
     * @param {Size} size
     * @returns {String}
     */
    
    /**
     * @typedef {Object} Settings
     *
     * @property {String} [template]
     *           A template string used to generate URLs for an image. This allows us to
     *           dynamically load images with sizes to match the container's size.
     *
     * @property {TemplateRenderer} [templateRender]
     *           A function to turn a template string into a URL.
     *
     * @property {Size} [max]
     *           The maximum available size for the image. This ensures we don't
     *           try to load an image larger than is possible.
     *
     * @property {Number} [round]
     *           Round image dimensions to the nearest multiple. This is intended to
     *           tax the image server less by lowering the number of possible image
     *           sizes requested.
     *
     * @property {Size} [placeholder]
     *           The size of the lo-fi image to load before the full image.
     */
    
    /**
     * Initialize the responsive image handler.
     *
     * @param {String|HTMLElement|NodeList} selector
     *        The CSS selector, element, or elements to track for lazy-loading.
     *
     * @param {Settings} options
     *
     * @returns {PublicApi}
     */
    function rimg() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg="lazy"]';
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    
      // Intersections
      var io = new IntersectionObserver(function (entries) {
        entries.forEach(function (entry) {
          if (entry.isIntersecting || entry.intersectionRatio > 0) {
            io.unobserve(entry.target);
            load(entry.target, options);
          }
        });
      }, {
        // Watch the viewport, with 20% vertical margins
        rootMargin: '20% 0px'
      });
    
      /**
       * @typedef {Object} PublicApi
       */
      var api = {
        /**
         * Track a new selector, element, or nodelist for lazy-loading.
         * @type Function
         * @param {String|HTMLElement|NodeList} selector
         */
        track: function track() {
          var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg="lazy"]';
    
          var els = querySelector(selector);
          for (var i = 0; i < els.length; i++) {
            io.observe(els[i]);
          }
        },
        update: function update$$1() {
          var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg="loaded"]';
    
          var els = querySelector(selector);
          for (var i = 0; i < els.length; i++) {
            update(els[i], options);
          }
        },
    
    
        /**
         * Stop tracking element(s) for lazy-loading.
         * @type Function
         * @param {String|HTMLElement|NodeList} selector
         */
        untrack: function untrack() {
          var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg]';
    
          var els = querySelector(selector);
          for (var i = 0; i < els.length; i++) {
            io.unobserve(els[i]);
          }
        },
    
    
        /**
         * Unload all event handlers and observers.
         * @type Function
         */
        unload: function unload() {
          io.disconnect();
        }
      };
    
      // Add initial elements
      api.track(selector);
    
      return api;
    }
    
    /**
     * Finds a group of elements on the page.
     *
     * @param {String|HTMLElement|NodeList} selector
     * @returns {Object} An array-like object.
     */
    function querySelector(selector) {
      if (typeof selector === 'string') {
        return document.querySelectorAll(selector);
      }
    
      if (selector instanceof HTMLElement) {
        return [selector];
      }
    
      if (selector instanceof NodeList) {
        return selector;
      }
    
      return [];
    }
    
    return rimg;
    
    })));
    
;


    /*!
     * rimg-shopify v2.2.0
     * (c) 2018 Pixel Union
     */
    (function (global, factory) {
    	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('rimg')) :
    	typeof define === 'function' && define.amd ? define(['rimg'], factory) :
    	(global.rimg = global.rimg || {}, global.rimg.shopify = factory(global.rimg));
    }(this, (function (rimg) { 'use strict';
    
    rimg = rimg && rimg.hasOwnProperty('default') ? rimg['default'] : rimg;
    
    /**
     * Polyfill for Element.matches().
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
     */
    if (!Element.prototype.matches) {
      Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
        var matches = (this.document || this.ownerDocument).querySelectorAll(s),
            i = matches.length;
        while (--i >= 0 && matches.item(i) !== this) {}
        return i > -1;
      };
    }
    
    var state = {
      init: init,
      watch: watch,
      unwatch: unwatch
    };
    
    function init() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg="lazy"]';
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    
      state.selector = selector;
      state.instance = rimg(selector, options);
      state.loadedWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    
      // Listen for Shopify theme editor events
      document.addEventListener('shopify:section:load', function (event) {
        return watch(event.target);
      });
    
      window.addEventListener('resize', function () {
        return _update();
      });
    
      document.addEventListener('shopify:section:unload', function (event) {
        return unwatch(event.target);
      });
    
      // Listen for custom events to allow themes to hook into rimg
      document.addEventListener('theme:rimg:watch', function (event) {
        return watch(event.target);
      });
    
      document.addEventListener('theme:rimg:unwatch', function (event) {
        return unwatch(event.target);
      });
    
      // Support custom events triggered through jQuery
      // See: https://github.com/jquery/jquery/issues/3347
      if (window.jQuery) {
        jQuery(document).on({
          'theme:rimg:watch': function themeRimgWatch(event) {
            return watch(event.target);
          },
          'theme:rimg:unwatch': function themeRimgUnwatch(event) {
            return unwatch(event.target);
          }
        });
      }
    }
    
    /**
     * Track an element, and its children.
     *
     * @param {HTMLElement} el
     */
    function watch(el) {
      // Track element
      if (typeof el.matches === 'function' && el.matches(state.selector)) {
        state.instance.track(el);
      }
    
      // Track element's children
      state.instance.track(el.querySelectorAll(state.selector));
    }
    
    /**
     * Untrack an element, and its children
     *
     * @param {HTMLElement} el
     * @private
     */
    function unwatch(el) {
      // Untrack element's children
      state.instance.untrack(el.querySelectorAll(state.selector));
    
      // Untrack element
      if (typeof el.matches === 'function' && el.matches(state.selector)) {
        state.instance.untrack(el);
      }
    }
    
    /**
     * Update an element, and its children.
     *
     * @param {HTMLElement} el
     */
    function _update() {
      var currentWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    
      // Return if we're not 2x smaller, or larger than the existing loading size
      if (currentWidth / state.loadedWidth > 0.5 && currentWidth / state.loadedWidth < 2) {
        return;
      }
    
      state.loadedWidth = currentWidth;
      state.instance.update();
    }
    
    return state;
    
    })));
    
;

window.ThemeView = (function(superClass) {
  extend(ThemeView, superClass);

  function ThemeView() {
    return ThemeView.__super__.constructor.apply(this, arguments);
  }

  ThemeView.prototype.el = document.body;

  ThemeView.prototype.initialize = function() {
    var body;
    body = $(document.body);
    this.isHome = body.hasClass("template-index");
    this.isCollection = body.hasClass("template-collection");
    this.isListCollections = body.hasClass("template-list-collections");
    this.isProduct = body.hasClass("template-product");
    this.isCart = body.hasClass("template-cart");
    this.isPage = body.hasClass("template-page");
    this.isPassword = body.hasClass("template-password");
    this.isGiftCardPage = body.hasClass("gift-card-template");
    this.isAccount = body.attr("class").indexOf("-customers-") > 0;
    window.Pacific = {};
    return Pacific.settings = {{ settings | json }};
  };

  ThemeView.prototype.render = function() {
    var j, len, ref1, rte;
    this.sections = new ThemeEditor();
    this.sections.register('header', this.header(this.sections));
    this.sections.register('footer', this.footer(this.sections));
    this.sections.register('slideshow', this.slideshow(this.sections));
    this.sections.register('featured-video', this.video(this.sections));
    this.sections.register('featured-images', this.featuredImages(this.sections));
    this.sections.register('collection-list', this.collectionList(this.sections));
    this.sections.register('featured-collection', this.featuredCollection(this.sections));
    this.sections.register('pxs-map', this.mapSetup(this.sections));
    this.sections.register('featured-product', this.product(this.sections));
    this.sections.register('page-product', this.product(this.sections));
    new HeaderView({
      el: this.$el
    });
    ref1 = $(".rte");
    for (j = 0, len = ref1.length; j < len; j++) {
      rte = ref1[j];
      new RTEView({
        el: rte
      });
    }
    if (Pacific.settings["enable-sidebar"]) {
      new SidebarView({
        el: this.$(".sidebar")
      });
    }
    if (this.isCollection) {
      new CollectionView({
        el: this.$el
      });
    }
    if (this.isListCollections) {
      new ListCollectionsView({
        el: $(".collections-list")
      });
    }
    if (this.isCart) {
      new CartView({
        el: this.$el
      });
    }
    if (this.isAccount) {
      new AccountView({
        el: this.$el
      });
    }
    if (this.isPassword) {
      new PasswordView({
        el: this.$el
      });
    }
    if (this.isGiftCardPage) {
      new GiftCardView();
    }
    rimg["shopify"].init();
    if ($("html").hasClass("lt-ie10")) {
      return this.inputPlaceholderFix();
    }
  };

  ThemeView.prototype.header = function(sections) {
    return {
      instances: {},
      init: function(instance) {
        return this.instances[instance.sectionId] = new NavigationView({
          el: instance.$container
        });
      },
      onSectionLoad: function(event) {
        var instance;
        instance = sections.getInstance(event);
        if (this.instances[instance.sectionId] == null) {
          return this.init(instance);
        }
      },
      onSectionSelect: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        return (ref1 = this.instances[instance.sectionId]) != null ? ref1.update(instance.$container) : void 0;
      },
      onSectionUnload: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        if ((ref1 = this.instances[instance.sectionId]) != null) {
          ref1.remove();
        }
        return delete this.instances[instance.sectionId];
      }
    };
  };

  ThemeView.prototype.slideshow = function(sections) {
    return {
      instances: {},
      init: function(instance) {
        return this.instances[instance.sectionId] = new SlideshowView({
          el: instance.$container
        });
      },
      onSectionLoad: function(event) {
        var instance;
        instance = sections.getInstance(event);
        if (this.instances[instance.sectionId] == null) {
          return this.init(instance);
        }
      },
      onSectionSelect: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        return (ref1 = this.instances[instance.sectionId]) != null ? ref1.update(instance.$container) : void 0;
      },
      onSectionUnload: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        if ((ref1 = this.instances[instance.sectionId]) != null) {
          ref1.remove();
        }
        return delete this.instances[instance.sectionId];
      },
      onBlockSelect: function(event) {
        var instanceHandler;
        instanceHandler = this.instances[sections.getInstance(event).sectionId];
        return instanceHandler.lockSlide(event);
      },
      onBlockDeselect: function(event) {
        var instanceHandler;
        instanceHandler = this.instances[sections.getInstance(event).sectionId];
        return instanceHandler.unlockSlide();
      }
    };
  };

  ThemeView.prototype.video = function(sections) {
    return {
      instances: {},
      init: function(instance) {
        return this.instances[instance.sectionId] = new VideoView({
          el: instance.$container
        });
      },
      onSectionLoad: function(event) {
        var instance;
        instance = sections.getInstance(event);
        if (this.instances[instance.sectionId] == null) {
          return this.init(instance);
        }
      },
      onSectionSelect: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        return (ref1 = this.instances[instance.sectionId]) != null ? ref1.update(instance.$container) : void 0;
      },
      onSectionUnload: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        if ((ref1 = this.instances[instance.sectionId]) != null) {
          ref1.remove();
        }
        return delete this.instances[instance.sectionId];
      }
    };
  };

  ThemeView.prototype.featuredImages = function(sections) {
    return {
      instances: {},
      init: function(instance) {
        return this.instances[instance.sectionId] = new FeaturedImagesView({
          el: instance.$container
        });
      },
      onSectionLoad: function(event) {
        var instance;
        instance = sections.getInstance(event);
        if (this.instances[instance.sectionId] == null) {
          return this.init(instance);
        }
      },
      onSectionSelect: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        return (ref1 = this.instances[instance.sectionId]) != null ? ref1.update(instance.$container) : void 0;
      },
      onSectionUnload: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        if ((ref1 = this.instances[instance.sectionId]) != null) {
          ref1.remove();
        }
        return delete this.instances[instance.sectionId];
      }
    };
  };

  ThemeView.prototype.featuredCollection = function(sections) {
    return {
      instances: {},
      init: function(instance) {
        return this.instances[instance.sectionId] = new FeaturedProductsView({
          el: instance.$container
        });
      },
      onSectionLoad: function(event) {
        var instance;
        instance = sections.getInstance(event);
        if (this.instances[instance.sectionId] == null) {
          return this.init(instance);
        }
      },
      onSectionSelect: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        return (ref1 = this.instances[instance.sectionId]) != null ? ref1.update(instance.$container) : void 0;
      },
      onSectionUnload: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        if ((ref1 = this.instances[instance.sectionId]) != null) {
          ref1.remove();
        }
        return delete this.instances[instance.sectionId];
      }
    };
  };

  ThemeView.prototype.mapSetup = function(sections) {
    return {
      instances: {},
      init: function(instance) {
        return this.instances[instance.sectionId] = new PxsMap({
          el: instance.el,
          data: instance.data
        });
      },
      onSectionLoad: function(event) {
        var instance;
        instance = sections.getInstance(event);
        if (!this.instances[instance.sectionId]) {
          return this.init(instance);
        }
      },
      onSectionUnload: function(event) {
        var instance;
        instance = sections.getInstance(event);
        this.instances[instance.sectionId].onSectionUnload();
        return delete this.instances[instance.sectionId];
      }
    };
  };

  ThemeView.prototype.product = function(sections) {
    return {
      instances: {},
      init: function(instance) {
        return this.instances[instance.sectionId] = new ProductView({
          el: instance.el,
          data: instance.data
        });
      },
      onSectionLoad: function(event) {
        var instance;
        instance = sections.getInstance(event);
        if (this.instances[instance.sectionId] == null) {
          return this.init(instance);
        }
      },
      onSectionUnload: function(event) {
        var instance;
        instance = sections.getInstance(event);
        this.instances[instance.sectionId].onSectionUnload();
        return delete this.instances[instance.sectionId];
      }
    };
  };

  ThemeView.prototype.collectionList = function(sections) {
    return {
      instances: {},
      init: function(instance) {
        return this.instances[instance.sectionId] = new FeaturedCollectionsView({
          el: instance.$container
        });
      },
      onSectionLoad: function(event) {
        var instance;
        instance = sections.getInstance(event);
        if (this.instances[instance.sectionId] == null) {
          return this.init(instance);
        }
      },
      onSectionSelect: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        return (ref1 = this.instances[instance.sectionId]) != null ? ref1.update(instance.$container) : void 0;
      },
      onSectionUnload: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        if ((ref1 = this.instances[instance.sectionId]) != null) {
          ref1.remove();
        }
        return delete this.instances[instance.sectionId];
      }
    };
  };

  ThemeView.prototype.footer = function(sections) {
    return {
      instances: {},
      init: function(instance) {
        return this.instances[instance.sectionId] = new FooterView({
          el: instance.$container
        });
      },
      onSectionLoad: function(event) {
        var instance;
        instance = sections.getInstance(event);
        if (this.instances[instance.sectionId] == null) {
          return this.init(instance);
        }
      },
      onSectionSelect: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        return (ref1 = this.instances[instance.sectionId]) != null ? ref1.update(instance.$container) : void 0;
      },
      onSectionUnload: function(event) {
        var instance, ref1;
        instance = sections.getInstance(event);
        if ((ref1 = this.instances[instance.sectionId]) != null) {
          ref1.remove();
        }
        return delete this.instances[instance.sectionId];
      }
    };
  };

  ThemeView.prototype.inputPlaceholderFix = function() {
    var input, j, len, placeholders, text;
    placeholders = $("[placeholder]");
    for (j = 0, len = placeholders.length; j < len; j++) {
      input = placeholders[j];
      input = $(input);
      if (!(input.val().length > 0)) {
        text = input.attr("placeholder");
        input.attr("value", text);
        input.data("original-text", text);
      }
    }
    placeholders.focus(function() {
      input = $(this);
      if (input.val() === input.data("original-text")) {
        return input.val("");
      }
    });
    return placeholders.blur(function() {
      input = $(this);
      if (input.val().length === 0) {
        return input.val(input.data("original-text"));
      }
    });
  };

  return ThemeView;

})(Backbone.View);

$(function() {
  window.theme = new ThemeView();
  return theme.render();
});
